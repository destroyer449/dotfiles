#+title: My personal Doom Emacs config
#+author: Dominic Adamson
#+title: Doom Emacs Configuration
#+subtitle: What Hell (Probably) Feels Like
#+startup: fold
#+property: header-args:emacs-lisp :tangle yes
#+property: header-args :tangle no :results silent :eval no-export
#+options: coverpage:yes

#+begin_export html
<a href="https://github.com/destroyer449/dotfiles/tree/master/.config/doom/"
   style="font-family: 'Open Sans'; background-image: none; color: inherit;
   text-decoration: none; position: relative; top: clamp(-26px, calc(1280px - 100vw), 0px); opacity: 0.7;">
  <img src="https://upload.wikimedia.org/wikipedia/commons/9/91/Octicons-mark-github.svg"
       class="invertible" alt="GitHub Octicon"
       style="height: 1em; position: relative; top: 0.1em;">
  View on GitHub</a>
#+end_export

#+begin_quote
If we want to keep human knowledge open and freely available to humanity, we have to do the work to make it available that way. We have to write a free encyclopedia. @@latex:\mbox{@@--- Richard Stallman@@latex:}@@
#+end_quote

* Intro
Customizing things is great. TBH, its 90% of what I do on a computer. The downside is, you can't use these customized programs everywhere. This is really painful for editors, as you spend countless millenia perfecting your workflow, and then leave it. This is basically what lead me to use emacs, as I was always seeing on the internet that it can do anything. And while it can't do /anything/, its as close as you're going to get.

When I first heard about emacs, the other big thing I heard about were "emacs-pinky" and the difficulty of e-lisp. I was also a long time vim user (I've used it the entire time I've used linux), so I wanted to find a way to use the vim keybinding too. As such, I was led to the =spacemacs= distribution, and I used it for a couple months. My main complaints were that it honestly makes configuring harder, not easier, and that it makes installing non-spacemacs packages harder than it should be. Shortly after, I heard about =doom emacs= and thought I should try using it for a while. I personally think that this is one of the best ways to use emacs.

Since then, I've learned about literate programming, and the joys of =org-mode=, and have gotten to the point where I refuse to use anything but this. This here is the result of this obsession, in the form of my emacs configuration file to extend doom.

** Why Emacs?
If you ask any emacs user why they like emacs, they're all going to give you different answers. However, I like the explanation that [[https://github.com/tecosaur][Tecosaur]] has in /his/ literate config (which /may/ be where I got 70% of this code, and the current structure...), so I'll put it here...

Emacs is [[https://www.eigenbahn.com/2020/01/12/emacs-is-no-editor][not a text editor]], this is a common misnomer. It is far more apt to
describe Emacs as /a Lisp machine providing a generic user-centric text
manipulation environment/. That's quite a mouthful.
In simpler terms one can think of Emacs as a platform for text-related
applications. It's a vague and generic definition because Emacs itself is
generic.

Good with text. How far does that go? A lot further than one initially thinks:
+ [[https://orgmode.org/][Task planning]]
+ [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Dired.html][File management]]
+ [[https://github.com/akermu/emacs-libvterm][Terminal emulation]]
+ [[https://www.djcbsoftware.nl/code/mu/mu4e.html][Email client]]
+ [[https://www.gnu.org/software/tramp/][Remote server tool]]
+ [[https://magit.vc/][Git frontend]]
+ Web [[https://github.com/pashky/restclient.el][client]]/[[https://github.com/skeeto/emacs-web-server][server]]
+ and more...

Ideally, one may use Emacs as /the/ interface to perform =input → transform →
output= cycles, i.e. form a bridge between the human mind and information
manipulation.

*** The enveloping editor
Emacs allows one to do more in one place than any other application. Why is this
good?
+ Enables one to complete tasks with a consistent, standard set of keybindings,
  GUI and editing methods --- learn once, use everywhere
+ Reduced context-switching
+ Compressing the stages of a project --- a more centralised workflow can progress
  with greater ease
+ Integration between tasks previously relegated to different applications, but
  with a common subject --- e.g. linking to an email in a to-do list

Emacs can be thought of as a platform within which various elements of your
workflow may settle, with the potential for rich integrations between them --- a
/life/ IDE if you will.

Today, many aspects of daily computer usage are split between different
applications which act like islands, but this often doesn't mirror how we
/actually use/ our computers. Emacs, if one goes down the rabbit hole, can give
users the power to bridge this gap.

#+name: emacs-platform
#+begin_src dot :cmd circo :file misc/emacs-platform.svg :exports none
digraph {
    graph [bgcolor="transparent"];
    node  [shape="underline" penwidth="2" style="rounded,filled" fillcolor="#efefef" color="#c9c9c9" fontcolor="#000000" fontname="overpass"];
    edge  [arrowhead=none color="#aaaaaa" penwidth="1.2"]
    // nodes
    "Task Managment" [color="#2ec27e"]
    "Email" [color="#1c71d8"]
    "Office suite" [color="#813d9c"]
    "Code editor" [color="#f5c211"]
    "Git client" [color="#e66100"]
    // "News feed" [color="#c01c28"]
    // "Personal Knowledge Base" [color="#986a44"]

    "Task Managment" -> "Email"
    "Task Managment" -> "Office suite"
    "Task Managment" -> "Code editor"
    "Task Managment" -> "Git client"
    // "Task Managment" -> "News feed"
    // "Task Managment" -> "Personal Knowledge Base"

    "Email" -> "Office suite"
    "Email" -> "Code editor"
    "Email" -> "Git client"
    // "Email" -> "Personal Knowledge Base"

    "Office suite" -> "Code editor"
    "Office suite" -> "Git client"
    // "Office suite" -> "News feed"
    // "Office suite" -> "Personal Knowledge Base"

    "Code editor" -> "Git client"

    // "News feed" -> "Personal Knowledge Base"
}
#+end_src

#+caption: Some sample workflow integrations that can be used within Emacs
#+attr_html: :class invertible :alt Graph of possible Emacs task integrations :style max-width:min(24em,100%)
#+attr_latex: :width 0.55\linewidth
[[file:misc/emacs-platform.svg]]

*** Some notably unique features
+ Recursive editing
+ Completely introspectable, with pervasive docstrings
+ Mutable environment, which can be incrementally modified
+ Functionality without applications
+ Client-server separation allows for a daemon, giving near-instant perceived
  startup time.

*** Issues
+ Emacs has irritating quirks
+ Some aspects are showing their age (naming conventions, APIs)
+ Emacs is ([[https://www.gnu.org/software/emacs/manual/html_node/elisp/Threads.html][mostly]]) single-threaded, meaning that when something holds that
  thread up the whole application freezes
+ A few other nuisances

*** Teach a man to fish...
#+begin_quote
Give a man a fish, and you feed him for a day. Teach a man to fish, and you feed
him for a lifetime. --- Anne Isabella
#+end_quote

Most popular editors have a simple and pretty [[https://code.visualstudio.com/docs/getstarted/settings][settings interface]], filled with
check-boxes, selects, and the occasional text-box. This makes it easy for the
user to pick between common desirable behaviours. To me this is now like /giving
a man a fish/.

What if you want one of those 'check-box' settings to be only on in certain
conditions? Some editors have workspace settings, but that requires you to
manually set the value for /every single instance/. Urgh, [[https://github.com/microsoft/vscode/issues/93153][what]] [[https://github.com/microsoft/vscode/issues/93628][a]] [[https://github.com/microsoft/vscode/issues/5595][pain]].

What if you could set the value of that 'check-box' setting to be the result of
an arbitrary expression evaluated for each file? This is where an editor like
Emacs comes in.
Configuration for Emacs isn't a list of settings in JSON etc. it's *an executable
program which modifies the behaviour of the editor to suit your liking*.
This is 'teaching a man to fish'.

Emacs is built in the same language you configure it in (Emacs [[https://en.wikipedia.org/wiki/Lisp_(programming_language)][Lisp]], or [[https://www.gnu.org/software/emacs/manual/html_node/eintr/][elisp]]).
It comes with a broad array of useful functions for text-editing, and Doom adds
a few handy little convenience functions.

Want to add a keybinding to delete the previous line? It's as easy as
#+name: Keybinding to delete the previous line
#+begin_src emacs-lisp :tangle no
(map! "C-d"
      (cmd! (previous-line)
            (kill-line)
            (forward-line)))
#+end_src

How about another example, say you want to be presented with a list of currently
open /buffers/ (think files, almost) when you split the window. It's as simple as
#+name: Prompt for buffer after split
#+begin_src emacs-lisp :tangle no
(defadvice! prompt-for-buffer (&rest _)
  :after 'window-split (switch-to-buffer))
#+end_src

Want to test it out? You don't need to save and restart, you can just /evaluate
the expression/ within your current Emacs instance and try it immediately! This
editor is, after all, a Lisp interpreter.

Want to tweak the behaviour? Just re-evaluate your new version --- it's a
super-tight iteration loop.

** Editor comparison

Over the years I have tried out (spent at least a year using as my primary
editor) the following applications
- Python IDLE
- ViM/Neovim
- PyCharm/IntelliJ
- VSCode
- and now, Emacs

I have attempted to quantify aspects of my impressions of them below.

#+plot: transpose:yes type:radar min:0 max:4 ticks:4 file:"misc/editor-comparison.svg"
| Editor           | Extensibility | Ecosystem | Ease of Use | Comfort | Completion | Performance |
|------------------+---------------+-----------+-------------+---------+------------+-------------|
| IDLE             |             1 |         1 |           2 |       1 |          1 |           2 |
| VSCode           |             3 |         3 |         3.5 |       2 |          4 |           3 |
| Vim              |           3.5 |       3.5 |         2.5 |     3.5 |          2 |           4 |
| Emacs            |             4 |         4 |           2 |       4 |        3.5 |           3 |
| PyCharm/IntelliJ |             3 |         2 |         3.5 |       3 |          4 |           1 |

#+attr_html: :class invertible :alt Radar chart comparing my thoughts on a few editors.
#+attr_latex: :options inkscapelatex=false
[[file:misc/editor-comparison.svg]]
* Basic Configurations
For some reason, files run (slightly) faster if they have lexical binding, but I have no idea why, or how. If you want to take a crack at figuring out why, read this [[https://nullprogram.com/blog/2016/12/22/][blog post]].
#+begin_src emacs-lisp
;;; config.el -*- lexical binding: t; -*-
#+end_src
** Better Defaults
*** Simple Settings
From looking at other people's configs, these are the basic options that I have decided upon.
#+begin_src emacs-lisp
(setq-default
 delete-by-moving-to-trash t                      ; Delete files to trash
 window-combination-resize t                      ; take new window space from all other windows (not just current)
 x-stretch-cursor t)                              ; Stretch cursor to the glyph width

(setq undo-limit 80000000                         ; Raise undo-limit to 80Mb
      evil-want-fine-undo t                       ; By default while in insert all changes are one big blob. Be more granular
      auto-save-default t                         ; Nobody likes to loose work, I certainly don't
      truncate-string-ellipsis "…")               ; Unicode ellispis are nicer than "...", and also save /precious/ space

(display-time-mode 1)                             ; Enable time in the mode-line

(if (equal "Battery status not available"
           (battery))
    (display-battery-mode 1)                        ; On laptops it's nice to know how much power you have
  (setq password-cache-expiry nil))               ; I can trust my desktops ... can't I? (no battery = desktop)

(global-subword-mode 1)                           ; Iterate through CamelCase words
(setq auth-sources '("~/.local/share/authinfo.gpg")
      auth-source-cache-expiry 3600)
#+end_src
*** Auto-customizations
By default, using the customization interface will put the variables in =init.el=, which is obviously stupid, considering I tangle that file from here...
#+begin_src emacs-lisp
(setq-default custom-file (expand-file-name "custom.el" doom-private-dir))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src
*** Windows
I hated this at first, but now I can't live without seeing what buffer should open when I make a split.

First, we have to get to the next window
#+begin_src emacs-lisp
(setq evil-vsplit-window-right t
      evil-split-window-below t)
#+end_src

Now, we just need to bring up =ivy=
#+begin_src emacs-lisp
(defadvice! prompt-for-buffer (&rest _)
  :after '(evil-window-split evil-window-vsplit)
  (+ivy/switch-buffer))
(setq +ivy-buffer-preview t)
#+end_src


Window rotation is in doom by default, but /layout/ rotation is not. This adds layout rotation under =SPC w SPC=, and arrow key versions of movements in case they ever come in handy.
#+begin_src emacs-lisp
(map! :map evil-window-map
      "SPC" #'rotate-layout
      ;; Navigation
      "<left>"     #'evil-window-left
      "<down>"     #'evil-window-down
      "<up>"       #'evil-window-up
      "<right>"    #'evil-window-right
      ;; Swapping windows
      "C-<left>"       #'+evil/window-move-left
      "C-<down>"       #'+evil/window-move-down
      "C-<up>"         #'+evil/window-move-up
      "C-<right>"      #'+evil/window-move-right)
#+end_src
*** Buffer Defaults
By default, emacs is going to open any new buffer in =fundamental-mode=, which does basically nothing. Why don't we just pull up a mode that's actually useful?
#+begin_src emacs-lisp
;; (setq-default major-mode 'org-mode)
#+end_src
I'm not sure why, but this breaks some stuff, so I guess we'll go without it.
** Doom Configuration
*** Modules
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
The thing that really made Doom stand out for me was the way that it handled modules. =Spacemacs= had them, but you set up modules by creating a list, and there was no way to tweak these modules except overriding them. Instead, doom has separate sections for each type of module, and you pass in flags to tweak their behavior. The other benefit to doom is that these modules won't be loaded or installed until you run =doom sync=, so performance is not nearly as much of a worry.
#+name: init.#+begin_src emacs-lisp :tangle yes
#+attr_html: :collapsed t
#+end_src
#+begin_src emacs-lisp :tangle "init.el" :noweb no-export :comments none
;;; init.el -*- lexical-binding: t; -*-

;; This file controls what Doom modules are enabled and what order they load in.
;; Press 'K' on a module to view its documentation, and 'gd' to browse its directory.

(doom! :completion
       <<doom-completion>>

       :ui
       <<doom-ui>>

       :editor
       <<doom-editor>>

       :emacs
       <<doom-emacs>>

       :term
       <<doom-term>>

       :checkers
       <<doom-checkers>>

       :tools
       <<doom-tools>>

       :os
       <<doom-os>>

       :lang
       <<doom-lang>>

       :email
       <<doom-email>>

       :app
       <<doom-app>>

       :config
       <<doom-config>>
       )
#+end_src
**** Structure
As you've (hopefully) noticed at this point, this is a literate config. Yet another thing that Doom does really well is its support for this with its =literate= module.
The =:config= section also has some nicer defaults, which aren't documented for some reason...
#+name: doom-config
#+begin_src emacs-lisp
literate
(default +bindings +smartparens)
#+end_src
**** Interface
Emacs' capabilities are basically limitless, so let's get as much of it as we can for free from Doom modules.

#+name: doom-completion
#+begin_src emacs-lisp
(company           ; the ultimate code completion backend
    +childframe)      ; the ultimate ui for code completion
;;(helm +fuzzy)    ; the *other* search engine for love and life
;;ido              ; the other *other* search engine...
(ivy +fuzzy        ; *the* search engine for love and life
    +icons         ; wasting clock cycles for nothing
    +prescient     ; typing less to remember more
    +childframe)   ; ivy anywhere you want it
#+end_src

#+name: doom-ui
#+begin_src emacs-lisp
;;deft             ; notational velocity for Emacs
doom               ; what makes DOOM look the way it does
doom-dashboard     ; a nifty splash screen for Emacs
doom-quit          ; DOOM quit-message prompts when you quit Emacs
(emoji             ; 🙂
 +unicode          ; standards are nice
 +ascii)           ; typing smilies is fun
;;fill-column      ; a `fill-column' indicator
hl-todo            ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
hydra              ; transient state controller
indent-guides      ; highlighted indent columns
minimap            ; show a map of the code on the side
modeline           ; snazzy, Atom-inspired modeline, plus API
nav-flash          ; blink cursor line after big motions
neotree            ; a project drawer, like NERDTree for vim
ophints            ; highlight the region an operation acts on
(popup +defaults)  ; tame sudden yet inevitable temporary windows
(ligatures +extra) ; ligatures or substitute text with pretty symbols
;;tabs             ; an tab bar for Emacs
;;treemacs         ; a project drawer, like neotree but cooler
unicode            ; extended unicode support for various languages
vc-gutter          ; vcs diff in the fringe
vi-tilde-fringe    ; fringe tildes to mark beyond EOB
window-select      ; visually switch windows
workspaces         ; tab emulation, persistence & separate workspaces
zen                ; distraction-free coding or writing
#+end_src

#+name: doom-editor
#+begin_src emacs-lisp
(evil +everywhere) ; come to the dark side, we have cookies
file-templates     ; auto-snippets for empty files
fold               ; (nigh) universal code folding
(format +onsave)   ; automated prettiness
;;god              ; run Emacs commands without modifier keys
;;lispy            ; vim for lisp, for people who don't like vim
multiple-cursors   ; editing in many places at once
;;objed            ; text object editing for the innocent
(parinfer +rust)   ; turn lisp into python, sort of
rotate-text        ; cycle region at point between text candidates
snippets           ; my elves. They type so I don't have to
word-wrap          ; soft wrapping with language-aware indent
#+end_src

#+name: doom-emacs
#+begin_src emacs-lisp
(dired +icons)     ; making dired pretty [functional]
electric           ; smarter, keyword-based electric-indent
(ibuffer +icons)   ; interactive buffer management
(undo +tree)       ; persistent, smarter undo for your inevitable mistakes
vc                 ; version-control and Emacs, sitting in a tree
#+end_src

#+name: doom-term
#+begin_src emacs-lisp
eshell             ; the elisp shell that works everywhere
;;shell            ; simple shell REPL for Emacs
;;term             ; basic terminal emulator for Emacs
vterm              ; the best terminal emulation in Emacs
#+end_src

#+name: doom-checkers
#+begin_src emacs-lisp
syntax             ; tasing you for every semicolon you forget
(:if (executable-find "aspell") (spell +aspell))
;; tasing you for every misspelling mispelling
grammar            ; tasing grammar mistake every you make
#+end_src

#+name: doom-tools
#+begin_src emacs-lisp
;;ansible
(debugger +lsp)    ; FIXME stepping through code, to help you add bugs
direnv
;;docker
editorconfig       ; let someone else argue about tabs vs spaces
;;ein              ; tame Jupyter notebooks with emacs
(eval +overlay)    ; run code, run (also, repls)
gist               ; interacting with github gists
(lookup            ; navigate your code and its documentation
 +dictionary      ; navigate the syntax of the english language
 +offline         ; why use the internet?
 +docsets)        ; integration is always nice...
(lsp +peek)
(magit +forge)     ; a git porcelain for Emacs
make               ; run make tasks from Emacs
;;pass             ; password manager for nerds
pdf                ; pdf enhancements
;;prodigy          ; FIXME managing external services & code builders
rgb                ; creating color strings
taskrunner         ; taskrunner for all your projects
;;terraform        ; infrastructure as code
;;tmux             ; an API for interacting with tmux
upload             ; map local to remote projects via ssh/ftp
#+end_src

#+name: doom-os
#+begin_src emacs-lisp
tty                ; improve the terminal Emacs experience
#+end_src
**** Language Support
Doom is pretty smart when it comes to language modules, so there is not tons of a performace hit until you open that file type. As such, just enable every language you know.

#+name: doom-lang
#+begin_src emacs-lisp
;;agda             ; types of types of types of types...
(cc +lsp)          ; C/C++/Obj-C madness
;;clojure          ; java with a lisp
;;common-lisp      ; if you've seen one lisp, you've seen them all
;;coq              ; proofs-as-programs
;;crystal          ; ruby at the speed of c
;;csharp           ; unity, .NET, and mono shenanigans
;;data             ; config/data formats
;;(dart +flutter)  ; paint ui and not much else
;;elixir           ; erlang done right
;;elm              ; care for a cup of TEA?
emacs-lisp         ; drown in parentheses
;;erlang           ; an elegant language for a more civilized age
;;ess              ; emacs speaks statistics
;;faust            ; dsp, but you get to keep your soul
;;fsharp           ; ML stands for Microsoft's Language
;;fstar            ; (dependent) types and (monadic) effects and Z3
;;gdscript         ; the language you waited for
;;(go +lsp)        ; the hipster dialect
(haskell +lsp)     ; a language that's lazier than I am
;;hy               ; readability of scheme w/ speed of python
;;idris            ; a language you can depend on
;;json             ; At least it ain't XML
(java +lsp)        ; the poster child for carpal tunnel syndrome
;;javascript       ; all(hope(abandon(ye(who(enter(here))))))
;;julia            ; a better, faster MATLAB
;;kotlin           ; a better, slicker Java(Script)
(latex +lsp        ; writing papers in Emacs has never been so fun
       +latexmk    ; why would you want to compile only once?
       +cdlatex)   ; math is better when you can type it
;;lean
;;factor
;;ledger           ; an accounting system in Emacs
(lua +lsp          ; one-based indices? one-based indices
     +moonscript)  ; one-based indices in classes
markdown           ; writing docs for people to ignore
;;nim              ; python + lisp at the speed of c
(:if (executable-find "nix") nix); I hereby declare "nix geht mehr!"
;;ocaml            ; an objective camel
(org +pretty       ; organize your plain life in less plain text
     +dragndrop    ; images are a pain to insert
     +brain        ; notes are useful if you remember them
     +noter        ; notes are even more useful when they are with content
     +gnuplot      ; we all hate excel
     +present      ; beamer is hard
     +roam         ; I don't know what this does, but it fixes a bug
     +pandoc)      ; org already exports enough
;;php              ; perl's insecure younger brother
;;plantuml         ; diagrams for confusing people more
;;purescript       ; javascript, but functional
(python +lsp       ; beautiful is better than ugly
        +pyenv     ; containers have never been more fun
        +conda     ; math for lazy nerds
        +poetry    ; package management is poetic
        +cython)   ; speed is nice
;;qt               ; the 'cutest' gui framework ever
;;racket           ; a DSL for DSLs
;;raku             ; the artist formerly known as perl6
;;rest             ; Emacs as a REST client
;;rst              ; ReST in peace
;;(ruby +rails)    ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
(rust +lsp)        ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
;;scala            ; java, but good
;;scheme           ; a fully conniving family of lisps
(sh +lsp)          ; she sells {ba,z,fi}sh shells on the C xor
;;sml              ; need-to-know and you don't need
;;solidity         ; do you need a blockchain? No.
;;swift            ; who asked for emoji variables?
;;terra            ; Earth and Moon in alignment for performance.
;;web              ; the tubes
(yaml +lsp)        ; JSON, but readable
#+end_src
**** Everything in Emacs
It's extremely nice to set up other programs to work inside of emacs. I have to do most of this manually, but the bare essentials are covered by doom modules.
#+name: doom-email
#+begin_src emacs-lisp
(:if (executable-find "mu") (mu4e +org +gmail))
;;notmuch
;;(wanderlust +gmail)
#+end_src

#+name: doom-app
#+begin_src emacs-lisp
calendar           ; A dated approach to timetabling
emms               ; Multimedia in Emacs is music to my ears
everywhere         ; *leave* Emacs!? You must be joking.
irc                ; how neckbeards socialize
(rss +org)         ; emacs as an RSS reader
;;twitter          ; twitter client https://twitter.com/vnought
#+end_src
*** Visual Settings
**** Font Face
'JetBrains Mono' is easily one of the best fonts I have ever found. I've found that 'Overpass' combines pretty well with most fonts, so I use this for variable pitch. The sizes of the fonts don't really match though, so I have to fiddle with those a lot
#+begin_src emacs-lisp
(setq doom-font (font-spec :family "JetBrainsMono Nerd Font" :size 12)
      doom-variable-pitch-font (font-spec :family "Overpass" :size 12)
      doom-big-font (font-spec :family "JetBrainsMono Nerd Font" :size 17)
      doom-unicode-font (font-spec :family "DejaVuSerif" :size 12)
      doom-serif-font (font-spec :family "IBM Plex Mono" :weight 'light :size 12))
#+end_src
In additions to these fonts, I use Merriweather for certain modes, and Cantarell as a serified proportional font for all of the aesthetic modes like =write-room=.

When you are missing specified fonts, doom likes to yell a lot. So, lets just add a check to prevent this from happening, eh?
#+name: detect-missing-fonts
#+begin_src emacs-lisp :tangle no
(defvar required-fonts '("JetBrainsMono.*" "Overpass" "DejaVuSerif" "IBM Plex Mono" "Merriweather" "Cantarell"))

(defvar available-fonts
  (delete-dups (or (font-family-list)
                   (split-string (shell-command-to-string "fc-list : family")
                                 "[,\n]"))))

(defvar missing-fonts
  (delq nil (mapcar
             (lambda (font)
               (unless (delq nil (mapcar (lambda (f)
                                           (string-match-p (format "^%s$" font) f))
                                         available-fonts))
                 font))
             required-fonts)))

(if missing-fonts
    (pp-to-string
     `(unless noninteractive
        (add-hook! 'doom-init-ui-hook
          (run-at-time nil nil
                       (lambda ()
                         (message "%s missing the following fonts: %s"
                                  (propertize "Warning!" 'face '(bold warning))
                                  (mapconcat (lambda (font)
                                               (propertize font 'face 'font-lock-variable-name-face))
                                             ',missing-fonts
                                             ", "))
                         (sleep-for 0.5))))))
  ";; No missing fonts detected")
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<detect-missing-fonts>>
#+end_src
**** Theme and Modeline
=doom-one=, the default theme for doom, is nice, but it's too blue for my taste. The best theme I have found in the =doom-themes= package would be =gruvbox-dark=, so let's load that. Oh, and why not make it easier to load themes in the future?
#+begin_src emacs-lisp
(setq doom-theme 'doom-gruvbox
      doom-gruvbox-dark-variant "hard"
      doom-gruvbox-brighter-comments t)
(delq! t custom-theme-load-path)
(map! :leader
      :desc "Load new themes" "t h" #'counsel-load-theme)
#+end_src
Because I use the daemon for everything, the modeline assumes that I don't want icons. Let's change that.
#+begin_src emacs-lisp
(setq doom-modeline-icon t)
#+end_src
While we're making the modeline less trash, why don't we remove information that's almost always the same, like line-endings or encoding?
#+begin_src emacs-lisp
(defun doom-modeline-conditional-buffer-encoding ()
  "We expect the encoding to be LF UTF-8, so only show the modeline when this is not the case"
  (setq-local doom-modeline-buffer-encoding
              (unless (and (memq (plist-get (coding-system-plist buffer-file-coding-system) :category)
                                 '(coding-category-undecided coding-category-utf-8))
                           (not (memq (coding-system-eol-type buffer-file-coding-system) '(1 2))))
                t)))

(add-hook 'after-change-major-mode-hook #'doom-modeline-conditional-buffer-encoding)
#+end_src
**** Miscellaneous
Relative line numbers are absolutely perfect for Vi-like editors, so you know exactly how far a motion will take you.
#+begin_src emacs-lisp
(setq display-line-numbers-type 'relative)
#+end_src
I'd like some nicer buffer names, too.
#+begin_src emacs-lisp
(setq doom-fallback-buffer-name "► Doom"
      +doom-dashboard-name "► Doom")
#+end_src
*** Babel Execution in CLI
This is a literate config, but =doom sync= is only capable of tangling the =config.el=. This means that I have to use the =org-tangle= command, but this asks for every code-block whether or not it should be evaluated. To fix this, we have to change the CLI commands with =$DOOMDIR/cli.el=, which is sourced every time a CLI command is run.
#+begin_src emacs-lisp :tangle cli.el :comments none
;;; cli.el -*- lexical-binding: t; -*-
(setq org-confirm-babel-evaluate nil)

(defun doom-shut-up-a (orig-fn &rest args)
  (quiet! (apply orig-fn args)))

(advice-add 'org-babel-execute-src-block :around #'doom-shut-up-a)
#+end_src
*** Async Tangling
Doom adds an =org-mode= hook =+literate-enable-recompile-h=. This is a nice idea, but it’s too blocking for my taste. Since I trust my tangling to be fairly straightforward, I’ll just redefine it to a simpler, async, function.
#+begin_src emacs-lisp
(defadvice! +literate-tangle-async-h ()
  "A very simplified version of `+literate-tangle-h', but async."
  :override #'+literate-tangle-h
  (let ((default-directory doom-private-dir))
    (async-shell-command
     (format "emacs --batch --eval \"(progn \
(require 'org) (setq org-confirm-babel-evaluate nil) \
(org-babel-tangle-file \\\"%s\\\"))\""
             +literate-config-file))))
#+end_src
** Other Things
*** Editor Interaction
**** Bookmarks
I'd like to keep my bookmarks separate from my buffers, thank you.
#+begin_src emacs-lisp
(map! :leader
      (:prefix ("B" . "bookmark")
        :desc "List bookmarks" "L" #'list-bookmarks
        :desc "Save current bookmarks to bookmark file" "w" #'bookmark-save
        :desc "Set bookmark" "m" #'bookmark-set
        :desc "Delete bookmark" "M" #'bookmark-delete)
      (:prefix ("b" . "buffer")
        :n "m" nil
        :n "M" nil))
#+end_src
**** Evaluate Elisp
The things that makes elisp such a great language is that you can evaluate it as you write. However, the bindings to do this are not ideal for someone who has used vim for years, so I'm changing them.
#+begin_src emacs-lisp
(map! :leader
      (:prefix ("e" . "evaluate")
       :desc "Evaluate elisp in buffer" "b" #'eval-buffer
       :desc "Evaluate defun" "d" #'eval-defun
       :desc "Evaluate elisp expression" "e" #'eval-expression
       :desc "Evaluate last sexpression" "l" #'eval-last-sexp
       :desc "Evaluate elisp in region" "r" #'eval-region))
#+end_src
**** Registers
Registers are a nice feature that I need to get into the habit of using more. It lets you save arbitrary text to any locations, and then call it back later To make registers easier to use, I make plenty of bindings for them.
#+begin_src emacs-lisp
(map! :leader
      (:prefix ("R" . "registers")
        :desc "Copy to register" "c" #'copy-to-register
        :desc "Frameset to register" "f" #'frameset-to-register
        :desc "Insert contents of register" "i" #'insert-register
        :desc "Jump to register" "j" #'jump-to-register
        :desc "List registers" "l" #'list-registers
        :desc "Number to register" "n" #'number-to-register
        :desc "Interactively choose a register" "r" #'counsel-register
        :desc "View a register" "v" #'view-register
        :desc "Window configuration to register" "w" #'window-configuration-to-register
        :desc "Increment register" "+" #'increment-register
        :desc "Point to register" "SPC" #'point-to-register))
#+end_src
**** Open Specific Files
There are some files that I open so much that it's better to just have bindings directly to those files, instead of registers or bookmarks.
#+begin_src emacs-lisp
(map! :leader
       (:prefix ("-" . "open file")
        :desc "Edit agenda file" "a" #'(lambda () (interactive) (find-file "~/org/agenda.org"))
        :desc "Edit doom config.org" "c" #'(lambda () (interactive) (find-file "~/.config/doom/config.org"))
        :desc "Edit eshell aliases" "e" #'(lambda () (interactive) (find-file "~/.config/doom/aliases"))
        :desc "Edit xmonad config" "x" #'(lambda () (interactive) (find-file "~/.config/xmonad/readme.org"))
        :desc "Edit alacritty config" "A" #'(lambda () (interactive) (find-file "~/.config/alacritty/alacritty.yml"))))
#+end_src
*** Window Title
Instead of saying "doom emacs," the title for the window should really be what we're editing, and what project that's in.
#+begin_src emacs-lisp
(setq frame-title-format
      '(""
        (:eval
         (if (s-contains-p org-roam-directory (or buffer-file-name ""))
             (replace-regexp-in-string
              ".*/[0-9]*-?" "☰ "
              (subst-char-in-string ?_ ?  buffer-file-name))
           "%b"))
        (:eval
         (let ((project-name (projectile-project-name)))
           (unless (string= "-" project-name)
             (format (if (buffer-modified-p)  " ◉ %s" "  ●  %s") project-name))))))
#+end_src
*** Splash Screen
Emacs is capable of rendering an image as a splash screen, or doing arbitrary computation to create a screen. [[https://github.com/MarioRicalde][@MarioRicalde]] created some great images, and now I just need to make some code to display the currect number of symbols based on the frame size...
#+begin_src emacs-lisp
(defvar fancy-splash-image-template
  (expand-file-name "misc/splash-images/emacs-e-template.svg" doom-private-dir)
  "Default template svg used for the splash image, with substitutions from ")

(defvar fancy-splash-sizes
  `((:height 300 :min-height 50 :padding (0 . 2))
    (:height 250 :min-height 42 :padding (2 . 4))
    (:height 200 :min-height 35 :padding (3 . 3))
    (:height 150 :min-height 28 :padding (3 . 3))
    (:height 100 :min-height 20 :padding (2 . 2))
    (:height 75  :min-height 15 :padding (2 . 1))
    (:height 50  :min-height 10 :padding (1 . 0))
    (:height 1   :min-height 0  :padding (0 . 0)))
  "list of plists with the following properties
  :height the height of the image
  :min-height minimum `frame-height' for image
  :padding `+doom-dashboard-banner-padding' (top . bottom) to apply
  :template non-default template file
  :file file to use instead of template")

(defvar fancy-splash-template-colours
  '(("$colour1" . keywords) ("$colour2" . type) ("$colour3" . base5) ("$colour4" . base8))
  "list of colour-replacement alists of the form (\"$placeholder\" . 'theme-colour) which applied the template")

(unless (file-exists-p (expand-file-name "theme-splashes" doom-cache-dir))
  (make-directory (expand-file-name "theme-splashes" doom-cache-dir) t))

(defun fancy-splash-filename (theme-name height)
  (expand-file-name (concat (file-name-as-directory "theme-splashes")
                            theme-name
                            "-" (number-to-string height) ".svg")
                    doom-cache-dir))

(defun fancy-splash-clear-cache ()
  "Delete all cached fancy splash images"
  (interactive)
  (delete-directory (expand-file-name "theme-splashes" doom-cache-dir) t)
  (message "Cache cleared!"))

(defun fancy-splash-generate-image (template height)
  "Read TEMPLATE and create an image if HEIGHT with colour substitutions as
   described by `fancy-splash-template-colours' for the current theme"
  (with-temp-buffer
    (insert-file-contents template)
    (re-search-forward "$height" nil t)
    (replace-match (number-to-string height) nil nil)
    (dolist (substitution fancy-splash-template-colours)
      (goto-char (point-min))
      (while (re-search-forward (car substitution) nil t)
        (replace-match (doom-color (cdr substitution)) nil nil)))
    (write-region nil nil
                  (fancy-splash-filename (symbol-name doom-theme) height) nil nil)))

(defun fancy-splash-generate-images ()
  "Perform `fancy-splash-generate-image' in bulk"
  (dolist (size fancy-splash-sizes)
    (unless (plist-get size :file)
      (fancy-splash-generate-image (or (plist-get size :template)
                                       fancy-splash-image-template)
                                   (plist-get size :height)))))

(defun ensure-theme-splash-images-exist (&optional height)
  (unless (file-exists-p (fancy-splash-filename
                          (symbol-name doom-theme)
                          (or height
                              (plist-get (car fancy-splash-sizes) :height))))
    (fancy-splash-generate-images)))

(defun get-appropriate-splash ()
  (let ((height (frame-height)))
    (cl-some (lambda (size) (when (>= height (plist-get size :min-height)) size))
             fancy-splash-sizes)))

(setq fancy-splash-last-size nil)
(setq fancy-splash-last-theme nil)
(defun set-appropriate-splash (&rest _)
  (let ((appropriate-image (get-appropriate-splash)))
    (unless (and (equal appropriate-image fancy-splash-last-size)
                 (equal doom-theme fancy-splash-last-theme)))
    (unless (plist-get appropriate-image :file)
      (ensure-theme-splash-images-exist (plist-get appropriate-image :height)))
    (setq fancy-splash-image
          (or (plist-get appropriate-image :file)
              (fancy-splash-filename (symbol-name doom-theme) (plist-get appropriate-image :height))))
    (setq +doom-dashboard-banner-padding (plist-get appropriate-image :padding))
    (setq fancy-splash-last-size appropriate-image)
    (setq fancy-splash-last-theme doom-theme)
    (+doom-dashboard-reload)))

(add-hook 'window-size-change-functions #'set-appropriate-splash)
(add-hook 'doom-load-theme-hook #'set-appropriate-splash)
#+end_src

Now the only thing missing is a an extra interesting line, whether that be some
corporate BS, an developer excuse, or a fun (useless) fact.

The following is rather long, but it essentially
+ fetches a phrase from an API
+ inserts it into the dashboard (asynchronously)
+ moves ~point~ to the phrase
+ re-uses the last phrase for requests within a few seconds of it being fetched

#+begin_src emacs-lisp
(defvar phrase-api-url
  (nth (random 3)
       '(("https://corporatebs-generator.sameerkumar.website/" :phrase)
         ("https://useless-facts.sameerkumar.website/api" :data)
         ("https://dev-excuses-api.herokuapp.com/" :text))))

(defmacro phrase-generate-callback (token &optional format-fn ignore-read-only callback buffer-name)
  `(lambda (status)
     (unless (plist-get status :error)
       (goto-char url-http-end-of-headers)
       (let ((phrase (plist-get (json-parse-buffer :object-type 'plist) (cadr phrase-api-url)))
             (inhibit-read-only ,(when (eval ignore-read-only) t)))
         (setq phrase-last (cons phrase (float-time)))
         (with-current-buffer ,(or (eval buffer-name) (buffer-name (current-buffer)))
           (save-excursion
             (goto-char (point-min))
             (when (search-forward ,token nil t)
               (with-silent-modifications
                 (replace-match "")
                 (insert ,(if format-fn format-fn 'phrase)))))
           ,callback)))))

(defvar phrase-last nil)
(defvar phrase-timeout 5)

(defmacro phrase-insert-async (&optional format-fn token ignore-read-only callback buffer-name)
  `(let ((inhibit-message t))
     (if (and phrase-last
              (> phrase-timeout (- (float-time) (cdr phrase-last))))
         (let ((phrase (car phrase-last)))
           ,(if format-fn format-fn 'phrase))
       (url-retrieve (car phrase-api-url)
                     (phrase-generate-callback ,(or token "\ufeff") ,format-fn ,ignore-read-only ,callback ,buffer-name))
       ;; For reference, \ufeff = Zero-width no-break space / BOM
       ,(or token "\ufeff"))))

(defun doom-dashboard-phrase ()
  (phrase-insert-async
   (progn
     (setq-local phrase-position (point))
     (mapconcat
      (lambda (line)
        (+doom-dashboard--center
         +doom-dashboard--width
         (with-temp-buffer
           (insert-text-button
            line
            'action
            (lambda (_)
              (setq phrase-last nil)
              (+doom-dashboard-reload t))
            'face 'doom-dashboard-menu-title
            'mouse-face 'doom-dashboard-menu-title
            'help-echo "Random phrase"
            'follow-link t)
           (buffer-string))))
      (split-string
       (with-temp-buffer
         (insert phrase)
         (setq fill-column (min 70 (/ (* 2 (window-width)) 3)))
         (fill-region (point-min) (point-max))
         (buffer-string))
       "\n")
      "\n"))
   nil t
   (progn
     (goto-char phrase-position)
     (forward-whitespace 1))
   +doom-dashboard-name))

(defadvice! doom-dashboard-widget-loaded-with-phrase ()
  :override #'doom-dashboard-widget-loaded
  (setq line-spacing 0.2)
  (insert
   "\n\n"
   (propertize
    (+doom-dashboard--center
     +doom-dashboard--width
     (doom-display-benchmark-h 'return))
    'face 'doom-dashboard-loaded)
   "\n"
   (doom-dashboard-phrase)
   "\n"))
#+end_src

Lastly, the dashboard's "useful" commands are of no use to me anymore, so let's turn all of it off and end up with a very clean splash screen.
#+begin_src emacs-lisp
(remove-hook '+doom-dashboard-functions #'doom-dashboard-widget-shortmenu)
(add-hook! '+doom-dashboard-mode-hook (hide-mode-line-mode 1) (hl-line-mode -1))
(setq-hook! '+doom-dashboard-mode-hook evil-normal-state-cursor (list nil))
#+end_src

However, when we run emacs in a terminal, we can't really get any of these features, so let's just make a simple ASCII banner.
#+begin_src emacs-lisp
(defun doom-dashboard-draw-ascii-emacs-banner-fn ()
  (let* ((banner
          '(
            "=================     ===============     ===============   ========  ========"
            "\\ . . . . . . .\\   //. . . . . . .\\   //. . . . . . .\\  \\. . .\\// . . //"
            "||. . ._____. . .|| ||. . ._____. . .|| ||. . ._____. . .|| || . . .\/ . . .||"
            "|| . .||   ||. . || || . .||   ||. . || || . .||   ||. . || ||. . . . . . . ||"
            "||. . ||   || . .|| ||. . ||   || . .|| ||. . ||   || . .|| || . | . . . . .||"
            "|| . .||   ||. _-|| ||-_ .||   ||. . || || . .||   ||. _-|| ||-_.|\ . . . . ||"
            "||. . ||   ||-'  || ||  `-||   || . .|| ||. . ||   ||-'  || ||  `|\_ . .|. .||"
            "|| . _||   ||    || ||    ||   ||_ . || || . _||   ||    || ||   |\ `-_/| . ||"
            "||_-' ||  .|/    || ||    \|.  || `-_|| ||_-' ||  .|/    || ||   | \  / |-_.||"
            "||    ||_-'      || ||      `-_||    || ||    ||_-'      || ||   | \  / |  `||"
            "||    `'         || ||         `'    || ||    `'         || ||   | \  / |   ||"
            "||            .===' `===.         .==='.`===.         .===' /==. |  \/  |   ||"
            "||         .=='   \_|-_ `===. .==='   _|_   `===. .===' _-|/   `==  \/  |   ||"
            "||      .=='    _-'    `-_  `='    _-'   `-_    `='  _-'   `-_  /|  \/  |   ||"
            "||   .=='    _-'          '-__\._-'         '-_./__-'         `' |. /|  |   ||"
            "||.=='    _-'                                                     `' |  /==.||"
            "=='    _-'                                                            \/   `=="
            "\   _-'                                                                `-_   /"
            " `''                                                                      ``'"))
         (longest-line (apply #'max (mapcar #'length banner))))
    (put-text-property
     (point)
     (dolist (line banner (point))
       (insert (+doom-dashboard--center
                +doom-dashboard--width
                (concat
                 line (make-string (max 0 (- longest-line (length line)))
                                   32)))
               "\n"))
     'face 'doom-dashboard-banner)))

(unless (display-graphic-p) ; for some reason this messes up the graphical splash screen atm
  (setq +doom-dashboard-ascii-banner-fn #'doom-dashboard-draw-ascii-emacs-banner-fn))
#+end_src
*** Systemd Daemon
to make emacs more useful, the emacs daemon runs in the background, and you connect to it. however, the daemon crashes rather frequently in gccemacs, so a systemd service is needed to make it more useful.
#+begin_src systemd :tangle ~/.config/systemd/user/emacs.service :mkdirp yes
[unit]
description=emacs server daemon
documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/

[service]
type=forking
execstart=sh -c 'emacs --daemon && emacsclient -c --eval "(delete-frame)"'
execstop=/usr/bin/emacsclient --no-wait --eval "(progn (setq kill-emacs-hook nil) (kill emacs))"
restart=on-failure

[install]
wantedby=default.target
#+end_src

which is then enabled by:
#+begin_src shell :tangle no
systemd --user enable emacs.service
#+end_src
For some reason, if you don't open a frame early on in the initialization, emacs refuses to open any later, so we add =&& emacsclient= to prevent this

Now, we just need to make emacs the =default app= for editing text, which is done using =.desktop= files
#+begin_src conf :tangle ~/.local/share/applications/emacs-client.desktop :mkdirp yes
[Desktop Entry]
Name=Emacs client
GenericName=Text Editor
Comment=A flexible platform for end-user applications
MimeType=text/english;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;
Exec=emacsclient -create-frame --alternate-editor="" --no-wait %F
Icon=emacs
Type=Application
Terminal=false
Categories=TextEditor;Utility;
StartupWMClass=Emacs
Keywords=Text;Editor;
X-KDE-StartupNotify=false
#+end_src

When I run the daemon, there are almost always a few particular things I use it for, so why not load them during startup?
#+begin_src emacs-lisp
(defun greedily-do-daemon-setup ()
  (require 'org)
  (when (require 'mu4e nil t)
    (setq mu4e-confirm-quit t)
    (setq +mu4e-lock-greedy t)
    (setq +mu4e-lock-relaxed t)
    (+mu4e-lock-add-watcher)
    (when (+mu4e-lock-available t)
      (mu4e~start)))
  (when (require 'elfeed nil t)
    (run-at-time nil (* 8 60 60) #'elfeed-update)))

(when (daemonp)
  (add-hook 'emacs-startup-hook #'greedily-do-daemon-setup)
  (add-hook! 'server-after-make-frame-hook (switch-to-buffer +doom-dashboard-name)))
#+end_src
*** Emacs Client Wrapper
When in a terminal emulator, I often want to use emacs. However, this is not very useful, as the client is blocking by default, and is bad at handling color support. To fix this, I could make a long alias, but it is slightly better to make a script that I can place in =~/.local/bin/=, so that I can use it in any shell.
I would use =sh= for the script, but its slightly easier to use arrays, so I'm using =bash=. If you don't have =bash=, most other shells like =csh= should also work.
#+begin_src shell :tangle ~/.local/bin/e :mkdirp yes :tangle-mode (identity #o755) :comments none
#!/usr/bin/env bash
force_tty=false
force_wait=false
stdin_mode=""

args=()

while :; do
    case "$1" in
        -t | -nw | --tty)
            force_tty=true
            shift ;;
        -w | --wait)
            force_wait=true
            shift ;;
        -m | --mode)
            stdin_mode=" ($2-mode)"
            shift 2 ;;
        -h | --help)
            echo -e "\033[1mUsage: e [-t] [-m MODE] [OPTIONS] FILE [-]\033[0m

Emacs client convenience wrapper.

\033[1mOptions:\033[0m
\033[0;34m-h, --help\033[0m            Show this message
\033[0;34m-t, -nw, --tty\033[0m        Force terminal mode
\033[0;34m-w, --wait\033[0m            Don't supply \033[0;34m--no-wait\033[0m to graphical emacsclient
\033[0;34m-\033[0m                     Take \033[0;33mstdin\033[0m (when last argument)
\033[0;34m-m MODE, --mode MODE\033[0m  Mode to open \033[0;33mstdin\033[0m with

Run \033[0;32memacsclient --help\033[0m to see help for the emacsclient."
            exit 0 ;;
        --*=*)
            set -- "$@" "${1%%=*}" "${1#*=}"
            shift ;;
        *)
            if [ "$#" = 0 ]; then
                break; fi
            args+=("$1")
            shift ;;
    esac
done

if [ ! "${#args[*]}" = 0 ] && [ "${args[-1]}" = "-" ]; then
    unset 'args[-1]'
    TMP="$(mktemp /tmp/emacsstdin-XXX)"
    cat > "$TMP"
    args+=(--eval "(let ((b (generate-new-buffer \"*stdin*\"))) (switch-to-buffer b) (insert-file-contents \"$TMP\") (delete-file \"$TMP\")${stdin_mode})")
fi

if [ -z "$DISPLAY" ] || $force_tty; then
    # detect terminals with sneaky 24-bit support
    if { [ "$COLORTERM" = truecolor ] || [ "$COLORTERM" = 24bit ]; } \
        && [ "$(tput colors 2>/dev/null)" -lt 257 ]; then
        if echo "$TERM" | grep -q "^\w\+-[0-9]"; then
            termstub="${TERM%%-*}"; else
            termstub="${TERM#*-}"; fi
        if infocmp "$termstub-direct" >/dev/null 2>&1; then
            TERM="$termstub-direct"; else
            TERM="xterm-direct"; fi # should be fairly safe
    fi
    emacsclient --tty -create-frame --alternate-editor="" "${args[@]}"
else
    if ! $force_wait; then
        args+=(--no-wait); fi
    emacsclient -create-frame --alternate-editor="" "${args[@]}"
fi
#+end_src
* Package Loading
:PROPERTIES:
:header-args:emacs-lisp: :tangle "packages.el" :comments no
:END:
This file shouldn't be byte compiled, but I don't understand why...
#+begin_src emacs-lisp
;; -*- no-byte-compile: t; -*-
#+end_src
** Loading Instructions
:PROPERTIES:
:header-args:emacs-lisp: :tangle no
:END:
This file, =packages.el= is where you define all of the external packages that you want installed. To install them, run =doom sync= on the command line. Afterwards, you will need to restart emacs somehow, preferably by restarting the daemon, or running =M-x doom/reload=.
#+begin_warning
Don't disable any of the core packages listed in =$EMACSDIR/core/packages.el=. Doom requires these packages, and disabling them will prevent doom from functioning correctly.
#+end_warning
*** Packages in MELPA/ELPA/Emacsmirror
To install ~some-package~ from these locations, just write:
#+begin_src emacs-lisp
(package! some-package)
#+end_src
*** Packages from git repositories
To install a package directly from a particular repo, you'll need to specify
a ~:recipe~. You'll find documentation on what ~:recipe~ accepts [[https://github.com/raxod502/straight.el#the-recipe-format][here]]:
#+begin_src emacs-lisp
(package! another-package
  :recipe (:host github :repo "username/repo"))
#+end_src

If the package you are trying to install does not contain a ~PACKAGENAME.el~
file, or is located in a subdirectory of the repo, you'll need to specify
~:files~ in the ~:recipe~:
#+begin_src emacs-lisp
(package! this-package
  :recipe (:host github :repo "username/repo"
           :files ("some-file.el" "src/lisp/*.el")))
#+end_src

*** Disabling built-in packages
If you'd like to disable a package included with Doom, for whatever reason,
you can do so here with the ~:disable~ property:
#+begin_src emacs-lisp
(package! builtin-package :disable t)
#+end_src
You can override the recipe of a built in package without having to specify
all the properties for ~:recipe~. These will inherit the rest of its recipe
from Doom or MELPA/ELPA/Emacsmirror:
#+begin_src emacs-lisp
(package! builtin-package :recipe (:nonrecursive t))
(package! builtin-package-2 :recipe (:repo "myfork/package"))
#+end_src

Specify a ~:branch~ to install a package from a particular branch or tag.
This is required for some packages whose default branch isn't 'master' (which
our package manager can't deal with; see [[https://github.com/raxod502/straight.el/issues/279][raxod502/straight.el#279]])
#+begin_src emacs-lisp
(package! builtin-package :recipe (:branch "develop"))
#+end_src
** General Packages
*** Window management
#+begin_src emacs-lisp
(package! rotate :pin "4e9ac3ff80...")
#+end_src

*** Fun
Sometimes one just wants a little fun. XKCD comics are fun.
#+begin_src emacs-lisp
(package! xkcd :pin "66e928706f...")
#+end_src

Every so often, you want everyone else to know that you’re typing, or just to amuse oneself. Introducing: typewriter sounds!
#+begin_src emacs-lisp
(package! selectric-mode :pin "1840de71f7...")
#+end_src

Hey, let’s get the weather in here while we’re at it. Unfortunately this seems slightly unmaintained (few open bugfix PRs) so let’s roll our own version.
#+begin_src emacs-lisp
(package! wttrin :recipe (:local-repo "lisp/wttrin"))
#+end_src

Why not flash words on the screen. Why not — hey, it could be fun.
#+begin_src emacs-lisp
(package! spray :pin "74d9dcfa2e...")
#+end_src

With all our fancy Emacs themes, my terminal is missing out!
#+begin_src emacs-lisp
(package! theme-magic :pin "844c4311bd...")
#+end_src

What’s even the point of using Emacs unless you’re constantly telling everyone about it?
#+begin_src emacs-lisp
(package! elcord :pin "25531186c1...")
#+end_src

For some reason, I find myself demoing Emacs every now and then. Showing what keyboard stuff I’m doing on-screen seems helpful. While screenkey does exist, having something that doesn’t cover up screen content is nice.
#+begin_src emacs-lisp
(package! keycast :pin "a3a0798349...")
#+end_src

Now lets just load this lazily.
#+begin_src emacs-lisp :tangle yes
(use-package! keycast
  :commands keycast-mode
  :config
  (define-minor-mode keycast-mode
    "Show current command and its key binding in the mode line."
    :global t
    (if keycast-mode
        (progn
          (add-hook 'pre-command-hook 'keycast--update t)
          (add-to-list 'global-mode-string '("" mode-line-keycast " ")))
      (remove-hook 'pre-command-hook 'keycast--update)
      (setq global-mode-string (remove '("" mode-line-keycast " ") global-mode-string))))
  (custom-set-faces!
    '(keycast-command :inherit doom-modeline-debug
                      :height 0.9)
    '(keycast-key :inherit custom-modified
                  :height 1.1
                  :weight bold)))
#+end_src

In a similar manner, gif-screencast may come in handy.
#+begin_src emacs-lisp
(package! gif-screencast :pin "1145e676b1...")
#+end_src
We can lazy load this using the start/stop commands.
There's some issues here though, so let's see if we can magic it together
TODO Improve =gif-screencast= documentation
#+begin_src emacs-lisp :tangle yes
(use-package! gif-screencast
  :commands gif-screencast-mode
  :config
  (map! :map gif-screencast-mode-map
        :g "<f8>" #'gif-screencast-toggle-pause
        :g "<f9>" #'gif-screencast-stop)
  (setq gif-screencast-program "maim"
        gif-screencast-args `("--quality" "3" "-i" ,(string-trim-right
                                                     (shell-command-to-string
                                                      "xdotool getactivewindow")))
        gif-screencast-optimize-args '("--batch" "--optimize=3" "--usecolormap=/tmp/doom-color-theme"))
  (defun gif-screencast-write-colormap ()
    (f-write-text
     (replace-regexp-in-string
      "\n+" "\n"
      (mapconcat (lambda (c) (if (listp (cdr c))
                                 (cadr c))) doom-themes--colors "\n"))
     'utf-8
     "/tmp/doom-color-theme" ))
  (gif-screencast-write-colormap)
  (add-hook 'doom-load-theme-hook #'gif-screencast-write-colormap))
#+end_src

Sometimes, logging the keys is not enough. I occasionally want to have a log of all the commands I ran, and everything that emacs spits our as a side buffer.
#+begin_src emacs-lisp
(package! command-log-mode)
#+end_src
*** Features
The very large files mode loads large files in chunks, allowing one to open ridiculously large files.
#+begin_src emacs-lisp
(package! vlf :recipe (:host github :repo "m00natic/vlfi" :files ("*.el"))
  :pin "cc02f25337...")
#+end_src

To make syntax highlighting better, the editor needs to parse the code and build a syntax tree. However, this is both computationally expensive, and requires the code to be ran. Treesitter somehow manages to side step both these issues, and remains editor agnostic, so why not use it?
#+begin_src emacs-lisp
(package! tree-sitter)
(package! tree-sitter-langs)
#+end_src

That said, if the directory doesn't exist we likely don't want to be using roam.
Since we don't want to trigger errors (which will happen as soon as roam tries
to initialise), let's not load roam.
#+begin_src emacs-lisp :noweb-ref none :tangle (if (file-exists-p "~/Documents/org/roam") "no" "packages.el")
(package! org-roam :disable t)
#+end_src

I am working on switching off of package.el, and this is all the left overs that I need.
#+begin_src emacs-lisp
(package! dmenu)
(package! peep-dired)
(package! wc-mode)
(package! vimrc-mode)
(package! org-appear :recipe (:host github :repo "awth13/org-appear")
  :pin "845be82b7a...")
(package! org-fragtog :pin "0151cabc7a...")
(package! org-pretty-tags :pin "5c7521651b...")
(package! engrave-faces :recipe (:local-repo "lisp/engrave-faces"))
(package! org-ref :pin "7dbe3ace9b...")
(package! org-graph-view :recipe (:host github :repo "alphapapa/org-graph-view") :pin "13314338d7...")
(package! org-chef :pin "5b461ed7d4...")
(package! systemd :pin "b6ae63a236...")
(package! org-pretty-table
  :recipe (:host github :repo "Fuco1/org-pretty-table") :pin "474ad84a8f...")
(package! info-colors)
(package! evil-terminal-cursor-changer :disable t)
#+end_src
* CENTAUR-TABS
To use tabs in Doom Emacs, be sure to uncomment "tabs" in Doom's init.el. Displays tabs at the top of the window similar to tabbed web browsers such as Firefox. I don't actually use tabs in Emacs. I placed this here mainly to practice E-Lisp, also in case I ever need it. In the default configuration of Doom Emacs, 'SPC t' is used for "toggle" keybindings, so I choose 'SPC t c' to toggle centaur-tabs.

| COMMAND                     | DESCRIPTION        | KEYBINDING       |
|-----------------------------+--------------------+------------------|
| centaur-tabs-local-mode     | Toggle tabs on/off | SPC t c          |
| centaur-tabs-forward        | Next tab           | g <right> or g t |
| centaur-tabs-backward       | Previous tab       | g <left> or g T  |
| centaur-tabs-forward-group  | Next tab group     | g <down>         |
| centaur-tabs-backward-group | Previous tab group | g <up>           |

#+begin_src emacs-lisp
(setq centaur-tabs-set-bar 'over
      centaur-tabs-set-icons t
      centaur-tabs-gray-out-icons 'buffer
      centaur-tabs-height 24
      centaur-tabs-set-modified-marker t
      centaur-tabs-style "slant"
      centaur-tabs-modified-marker "•")
(map! :leader
      :desc "Toggle tab locally" "t C" #'centaur-tabs-local-mode
      :desc "Toggle tabs on/off" "t c" #'centaur-tabs-mode)
#+end_src

* DIRED
Dired is the file manager within Emacs. Below, I setup keybindings for image previews (peep-dired). Doom Emacs does not use 'SPC d' for any of its keybindings, so I've chosen the format of 'SPC d' plus 'key'.

| COMMAND                                   | DESCRIPTION                              | KEYBINDING |
|-------------------------------------------+------------------------------------------+------------|
| dired                                     | Open dired file manager                  | SPC d d    |
| dired-jump                                | Jump to current directory in dired       | SPC d j    |
| (in dired) peep-dired                     | Toggle image previews within dired       | SPC d p    |
| (in dired) dired-view-file                | View file in dired                       | SPC d v    |
| (in peep-dired-mode) peep-dired-next-file | Move to next file in peep-dired-mode     | j          |
| (in peep-dired-mode) peep-dired-prev-file | Move to previous file in peep-dired-mode | k          |

#+begin_src emacs-lisp
(map! :leader
      (:prefix ("d" . "dired")
       :desc "Open dired" "d" #'dired
       :desc "Dired jump to current" "j" #'dired-jump)
      (:after dired
       (:map dired-mode-map
        :desc "Peep-dired image previews" "d p" #'peep-dired
        :desc "Dired view file" "d v" #'dired-view-file)))
(evil-define-key 'normal peep-dired-mode-map (kbd "j") 'peep-dired-next-file
  (kbd "k") 'peep-dired-prev-file)
(add-hook 'peep-dired-hook 'evil-normalize-keymaps)
(setq dired-open-extensions '(("gif" . "sxiv")
                              ("jpg" . "sxiv")
                              ("png" . "sxiv")
                              ("mkv" . "mpv")
                              ("mp4" . "mpv")))
#+end_src

* EWW
EWW is the Emacs Web Wowser, the builtin browser in Emacs. Below I set urls to open in a specific browser (eww) with browse-url-browser-function. By default, Doom Emacs does not use 'SPC e' for anything, so I choose to use the format 'SPC e' plus 'key' for these (I also use 'SPC e' for 'eval' keybindings).

#+begin_src emacs-lisp
(setq browse-url-browser-function 'eww-browse-url)
(map! :leader
      (:prefix ("e" . "evaluate/Eww")
       :desc "Eww web browser" "w" #'eww
       :desc "Eww reload page" "R" #'eww-reload
       :desc "Seach web for text in region" "s" #'eww-search-words
       :desc "Copy URL to clipboard" "c" #'eww-copy-page-url))
#+end_src

* CALC
Any sane person prefers radians and exact values
#+begin_src emacs-lisp
(setq calc-angle-mode 'rad  ; radians are rad
      calc-symbolic-mode t) ; keeps expressions like \sqrt{2} irrational for as long as possible
#+end_src

Embedded calc is a lovely feature which let’s us use calc to operate on LaTeX maths expressions. The standard keybinding is a bit janky however (C-x * e), so we’ll add a localleader-based alternative.
#+begin_src emacs-lisp
(map! :map calc-mode-map
      :after calc
      :localleader
      :desc "Embedded calc (toggle)" "e" #'calc-embedded)
(map! :map org-mode-map
      :after org
      :localleader
      :desc "Embedded calc (toggle)" "E" #'calc-embedded)
(map! :map latex-mode-map
      :after latex
      :localleader
      :desc "Embedded calc (toggle)" "e" #'calc-embedded)
#+end_src

Unfortunately this operates without the (rather informative) calculator and trail buffers, but we can advice it that we would rather like those in a side panel.
#+begin_src emacs-lisp
(defvar calc-embedded-trail-window nil)
(defvar calc-embedded-calculator-window nil)

(defadvice! calc-embedded-with-side-pannel (&rest _)
  :after #'calc-do-embedded
  (when calc-embedded-trail-window
    (ignore-errors
      (delete-window calc-embedded-trail-window))
    (setq calc-embedded-trail-window nil))
  (when calc-embedded-calculator-window
    (ignore-errors
      (delete-window calc-embedded-calculator-window))
    (setq calc-embedded-calculator-window nil))
  (when (and calc-embedded-info
             (> (* (window-width) (window-height)) 1200))
    (let ((main-window (selected-window))
          (vertical-p (> (window-width) 80)))
      (select-window
       (setq calc-embedded-trail-window
             (if vertical-p
                 (split-window-horizontally (- (max 30 (/ (window-width) 3))))
               (split-window-vertically (- (max 8 (/ (window-height) 4)))))))
      (switch-to-buffer "*Calc Trail*")
      (select-window
       (setq calc-embedded-calculator-window
             (if vertical-p
                 (split-window-vertically -6)
               (split-window-horizontally (- (/ (window-width) 2))))))
      (switch-to-buffer "*Calculator*")
      (select-window main-window))))
#+end_src

* FONTS
Settings related to fonts within Doom Emacs:
+ 'doom-font' -- standard monospace font that is used for most things in Emacs.
+ 'doom-variable-pitch-font' -- variable font which is useful in some Emacs plugins.
+ 'doom-big-font' -- used in doom-big-font-mode; useful for presentations.
+ 'font-lock-comment-face' -- for comments.
+ 'font-lock-keyword-face' -- for keywords with special significance, like ‘for’ and ‘if’ in C.
This also fixes the truncated mode line problem that occurs occasionally

#+begin_src emacs-lisp
(setq all-the-icons-scale-factor 1.2)

(autoload #'mixed-pitch-serif-mode "mixed-pitch"
  "Change the default face of the current buffer to a serifed variable pitch, while keeping some faces fixed pitch." t)

(after! mixed-pitch
  (defface variable-pitch-serif
    '((t (:family "serif")))
    "A variable-pitch face with serifs."
    :group 'basic-faces)
  (setq mixed-pitch-set-height t)
  (setq variable-pitch-serif-font (font-spec :family "Cantarell" :size 27))
  (set-face-attribute 'variable-pitch-serif nil :font variable-pitch-serif-font)
  (defun mixed-pitch-serif-mode (&optional arg)
    "Change the default face of the current buffer to a serifed variable pitch, while keeping some faces fixed pitch."
    (interactive)
    (let ((mixed-pitch-face 'variable-pitch-serif))
      (mixed-pitch-mode (or arg 'toggle)))))

(set-char-table-range composition-function-table ?f '(["\\(?:ff?[fijlt]\\)" 0 font-shape-gstring]))
(set-char-table-range composition-function-table ?T '(["\\(?:Th\\)" 0 font-shape-gstring]))
#+end_src

* IVY
Ivy is a generic completion mechanism similar to Helm but more lightweight.

** IVY-POSFRAME
Ivy-posframe is an ivy extension, which lets ivy use posframe to show its candidate menu. Some of the settings below involve:
+ ivy-posframe-display-functions-alist -- sets the display position for specific programs
+ ivy-posframe-height-alist -- sets the height of the list displayed for specific programs

Available functions (positions) for 'ivy-posframe-display-functions-alist'
+ ivy-posframe-display-at-frame-center
+ ivy-posframe-display-at-window-center
+ ivy-posframe-display-at-frame-bottom-left
+ ivy-posframe-display-at-window-bottom-left
+ ivy-posframe-display-at-frame-bottom-window-center
+ ivy-posframe-display-at-point
+ ivy-posframe-display-at-frame-top-center

~NOTE~: If the setting for 'ivy-posframe-display' is set to 'nil' (false), anything that is set to 'ivy-display-function-fallback' will just default to their normal position in Doom Emacs (usually a bottom split). However, if this is set to 't' (true), then the fallback position will be centered in the window.

#+begin_src emacs-lisp
(setq ivy-posframe-display-functions-alist
      '((swiper                     . ivy-posframe-display-at-point)
        (complete-symbol            . ivy-posframe-display-at-point)
        (counsel-M-x                . ivy-display-function-fallback)
        (counsel-esh-history        . ivy-posframe-display-at-window-center)
        (counsel-describe-function  . ivy-display-function-fallback)
        (counsel-describe-variable  . ivy-display-function-fallback)
        (counsel-find-file          . ivy-display-function-fallback)
        (counsel-recentf            . ivy-display-function-fallback)
        (counsel-register           . ivy-posframe-display-at-frame-bottom-window-center)
        (dmenu                      . ivy-posframe-display-at-frame-top-center)
        (nil                        . ivy-posframe-display))
      ivy-posframe-height-alist
      '((swiper . 20)
        (dmenu . 20)
        (t . 10)))
(add-hook 'ivy-mode-hook #'ivy-posframe-mode)
(setq ivy-read-action-function #'ivy-hydra-read-action)
#+end_src

** IVY KEYBINDINGS
By default, Doom Emacs has 'SPC w' for window related commands, so I put these bindings under 'SPC w i'

#+begin_src emacs-lisp
(map! :leader
      (:prefix ("w i" . "ivy")
       :desc "Push view" "p" #'ivy-push-view
       :desc "Switch view" "s" #'ivy-switch-view
       :desc "Pop view" "P" #'ivy-pop-view))
#+end_src

* MU4E
Setting up mu4e which is an email client that works within emacs. You must install mu4e and mbsync (isync in arch) through your Linux distribution's package manager. Setting up smtp for sending mail. Make sure the gnutls command line utils are installed. Package 'gnutls-bin' in Debian/Ubuntu, and 'gnutls' in Arch.

#+begin_src emacs-lisp
(require 'smtpmail)
(after! mu4e
  (setq mu4e-root-maildir "~/.local/share/mail"
        mu4e-get-mail-command "mbsync -c ~/.config/mbsync/mbsyncrc -a"
        mu4e-update-interval (* 10 60))

  (setq mu4e-contexts
        (list
         ;; Personal account
         (make-mu4e-context
          :name "Personal"
          :match-func
          (lambda (msg)
            (when msg
              (string-prefix-p "/Personal" (mu4e-message-field msg :maildir))))
          :vars '((user-mail-address . "adamson.dom@gmail.com")
                  (user-full-name    . "Dominic Adamson")
                  (mu4e-compose-signature . "Dominic Adamson via GMail")
                  (smtpmail-smtp-server  . "smtp.gmail.com")
                  (smtpmail-smtp-service . 587)
                  (mu4e-drafts-folder  . "/Personal/[Gmail]/Drafts")
                  (mu4e-sent-folder  . "/Personal/[Gmail]/Sent Mail")
                  (mu4e-refile-folder  . "/Personal/[Gmail]/All Mail")
                  (mu4e-trash-folder  . "/Personal/[Gmail]/Trash")))

         ;; School account
         (make-mu4e-context
          :name "School"
          :match-func
          (lambda (msg)
            (when msg
              (string-prefix-p "/SLCC" (mu4e-message-field msg :maildir))))
          :vars '((user-mail-address . "dadam126@bruinmail.slcc.edu")
                  (user-full-name    . "Dominic Adamson")
                  (mu4e-compose-signature . "Dominic Adamson\n Sent from mozilla thunderbird\n")
                  (smtpmail-smtp-server  . "smtp.gmail.com")
                  (smtpmail-smtp-service . 587)
                  (mu4e-drafts-folder  . "/SLCC/[Gmail]/Drafts")
                  (mu4e-sent-folder  . "/SLCC/[Gmail]/Sent Mail")
                  (mu4e-refile-folder  . "/SLCC/[Gmail]/All Mail")
                  (mu4e-trash-folder  . "/SLCC/[Gmail]/Trash")))))

  (setq mu4e-maildir-shortcuts
        '(("/Personal/Inbox"             . ?i)
          ("/Personal/[Gmail]/Sent Mail" . ?s)
          ("/Personal/[Gmail]/Trash"     . ?t)
          ("/Personal/[Gmail]/Drafts"    . ?d)
          ("/Personal/[Gmail]/All Mail"  . ?a)

          ("/SLCC/Inbox"                 . ?k)
          ("/SLCC/[Gmail]/Sent Mail"     . ?w)
          ("/SLCC/[Gmail]/Trash"         . ?g)
          ("/SLCC/[Gmail]/Drafts"        . ?e)
          ("/SLCC/[Gmail]/All Mail"      . ?q))))
#+end_src

* NEOTREE
Neotree is a file tree viewer. When you open neotree, it jumps to the current file thanks to ~neo-smart-open~. The neo-window-fixed-size setting makes the neotree width be adjustable. Doom Emacs had no keybindings set for neotree. Since Doom Emacs uses 'SPC t' for 'toggle' keybindings, I used 'SPC t n' for toggle-neotree.

#+begin_src emacs-lisp
(after! neotree
  (setq neo-smart-open t
        neo-window-fixed-size nil
        doom-themes-neotree-file-icons t))
(after! doom-themes
  (setq doom-neotree-enable-variable-pitch t))
(map! :leader
      :desc "Toggle neotree file viewer"
      "t n" #'neotree-toggle)
#+end_src

* LSP
LSP, or Language Server Protocol, is a standard created by microsoft for visual studio code that now is functional on almost every editor. It allows for a consistent interface to receive powerful IDE-like features across many languages. Here I enable every UI feature that lsp-ui provides.

#+begin_src emacs-lisp
(defun doom/lsp-mode-setup ()
  (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
  (lsp-ui-mode 1)
  (lsp-headerline-breadcrumb-mode 1)
  (lsp-ui-peek-enable 1)
  (setq lsp-ui-sideline-show-hover t))

(use-package! lsp-mode
  :hook (lsp-mode . doom/lsp-mode-setup))
#+end_src
** LSP Servers
Some languages and servers are not default on doom, even though they are the ones that function best. This section goes through and changes these defaults
#+begin_src emacs-lisp
(after! rustic
  (setq rustic-lsp-server 'rls))
(after! ccls
  (setq ccls-initialization-options '(:index (:comments 2) :completion (:detailedLabel t)))
  (set-lsp-priority! 'ccls 2))
#+end_src

* TREE-SITTER
Tree-sitter is a open standard with bindings to emacs (similar to LSP or DAP) that allows for improved "understanding" of code languages. This is used here primarily to get better syntax highlighting while coding.

#+begin_src emacs-lisp
(use-package! tree-sitter
  :config
  (require 'tree-sitter-langs)
  (global-tree-sitter-mode)
  (add-hook 'tree-sitter-after-on-hook #'tree-sitter-hl-mode))
#+end_src

* COMPANY MODE
Company mode is the preferred completion engine of doom emacs and integrates well with most plugins. The way it is configured in doom is almost perfect but I need to make a few adjustments, namely <TAB> functionality, to make it ideal.

It's nice to have completions almost all the time, in my opinion. Key strokes
are just waiting to be saved!
#+begin_src emacs-lisp
(after! company
  (setq company-idle-delay 0.5
        company-minimum-prefix-length 2)
  (setq company-show-numbers t)
  (add-hook 'evil-normal-state-entry-hook #'company-abort)) ;; make aborting less annoying.
#+end_src
Now, the improvements from ~precedent~ are mostly from remembering history, so
let's improve that memory.
#+begin_src emacs-lisp
(setq-default history-length 1000
              prescient-history-length 1000
              yas-triggers-in-field t)
#+end_src
** Plain Text
=Ispell= is nice, so let's have it on in all of the text modes, viz., =text=, =markdown=, and =GFM=.
#+begin_src emacs-lisp
(set-company-backend!
  '(text-mode
    markdown-mode
    gfm-mode)
  '(:seperate
    company-ispell
    company-files
    company-yasnippet))
#+end_src
* PROJECTILE MODE
#+begin_src emacs-lisp
(setq projectile-project-search-path '("~/Documents/code/" "~/.config/"))
#+end_src

* Language Configuration
** ORG MODE
:PROPERTIES:
:CUSTOM_ID: org
:header-args:emacs-lisp: :tangle no :noweb-ref org-conf
:END:
:intro:
TODO write org mode docs
:end:
#+begin_src emacs-lisp :noweb no-export :tangle yes :noweb-ref nil
(after! org
  <<org-conf>>
  )
#+end_src
*** System Configuration
**** MIME Types
For some reason, org doesn't have a mime type by default. However, we can fix this /really/ easily by making a random xml file from some place on the internet under ~/usr/share/mime/packages/~ for global use, or under ~~/.local/share/mime/packages~ for normal people
#+begin_src xml :tangle ~/.local/share/mime/packages/org.xml :mkdirp yes :comments none
<mime-info xmlns='http://www.freedesktop.org/standards/shared-mime-info'>
  <mime-type type="text/org">
    <comment>Emacs Org-mode File</comment>
    <glob pattern="*.org"/>
    <alias type="text/org"/>
  </mime-type>
</mime-info>
#+end_src
**** Git Diff
Git shows some information at the top of the diff that is normally pretty nice, but is useless for org mode. Some guy called Protesilos wrote about how to fix it in his [[https://protesilaos.com/codelog/2021-01-26-git-diff-hunk-elisp-org/][very helpful article]].
First, we need to make a new diff mode at ~~/.config/git/attributes~
#+begin_src fundamental
,*.org   diff=org
#+end_src

Then, just add a regex for that diff mode in ~~/.config/git/config~
#+begin_src gitconfig
[diff "org"]
	xfuncname = "^(\\*+ +.*)$"
#+end_src
*** Behavior
**** Defaults
#+begin_src emacs-lisp
(setq org-directory "~/.org"                      ; let's put files here
      org-use-property-inheritance t              ; it's convenient to have properties inherited
      org-log-done 'time                          ; having the time a item is done sounds convenient
      org-log-done 'note                          ; being able to write about what you've done is nice
      org-list-allow-alphabetical t               ; have a. A. a) A) list bullets
      org-export-in-background t                  ; run export processes in external emacs process
      org-catch-invisible-edits 'smart            ; try not to accidently do weird stuff in invisible regions
      org-export-with-sub-superscripts '{})       ; don't treat lone _ / ^ as sub/superscripts, require _{} / ^{}
#+end_src

The =:comments:= header-argument is really useful, so let's make it the standard.
#+begin_src emacs-lisp
(setq org-babel-default-header-args
      '((:session . "none")
        (:results . "replace")
        (:exports . "code")
        (:cache . "no")
        (:noweb . "no")
        (:hlines . "no")
        (:tangle . "no")
        (:comments . "link")))
#+end_src

For some reason, someone thought it would be a good idea to turn ~visual-line-mode~ =on=, and ~auto-fill-mode~ =off=, even though this breaks most of the great features of org mode and \LaTeX, so we'll just turn it off, and switch it back on for less important modes.
#+begin_src emacs-lisp
(remove-hook 'text-mode-hook #'visual-line-mode)
(add-hook 'tex-mode-hook #'auto-fill-mode)
#+end_src

On /very/ rare occasions, I find that I don't want to use the =hjkl= keys, and instead want arrows, so let's add it.
#+begin_src emacs-lisp
(map! :map evil-org-mode-map
      :after evil-org
      :n "g <up>" #'org-backward-heading-same-level
      :n "g <down>" #'org-forward-heading-same-level
      :n "g <left>" #'org-up-element
      :n "g <right>" #'org-down-element)
#+end_src

Right now, some of the basic ~evil-org~ keys are shadowed, making it hard to move. There is a pull open on doom to fix this, but it hasn't merged yet, so I'll just do it the lazy way
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'evil-org-mode)
(map! :map evil-org-mode-map
      :after evil-org
      :n "g k" #'org-backward-heading-same-level
      :n "g j" #'org-forward-heading-same-level
      :n "g h" #'org-up-element
      :n "g l" #'org-down-element)
#+end_src
**** Extra Functionality
***** Buffer Creation
Org is great and all, but it can occasionally be a pain to make an org buffer, so let's change that.
#+begin_src emacs-lisp
(evil-define-command evil-buffer-org-new (count file)
  "Creates a new ORG buffer replacing the current window, optionally
   editing a certain FILE"
  :repeat nil
  (interactive "P<f>")
  (if file
      (evil-edit file)
    (let ((buffer (generate-new-buffer "*new org*")))
      (set-window-buffer nil buffer)
      (with-current-buffer buffer
        (org-mode)))))
(map! :leader
      (:prefix "b"
       :desc "New empty ORG buffer" "o" #'evil-buffer-org-new))
#+end_src
***** List Bullets
When you have depth on a bullet sequence, the bullets should change.
#+begin_src emacs-lisp
(setq org-list-demote-modify-bullet '(("+" . "-") ("-" . "+") ("*" . "+") ("1." . "a.")))
#+end_src
***** Citations
On certain occasions, I need to cite something or other. There exists a package =org-ref= for that exact purpose, but it ignores local citation files like =.bib=
#+begin_src emacs-lisp
(use-package! org-ref
  :after org
  :config
  (setq org-ref-completion-library 'org-ref-ivy-cite)
  (defadvice! org-ref-open-bibtex-pdf-a ()
    :override #'org-ref-open-bibtex-pdf
    (save-excursion
      (bibtex-beginning-of-entry)
      (let* ((bibtex-expand-strings t)
             (entry (bibtex-parse-entry t))
             (key (reftex-get-bib-field "=key=" entry))
             (pdf (or
                   (car (-filter (lambda (f) (string-match-p "\\.pdf$" f))
                                 (split-string (reftex-get-bib-field "file" entry) ";")))
                   (funcall org-ref-get-pdf-filename-function key))))
        (if (file-exists-p pdf)
            (org-open-file pdf)
          (ding)))))
  (defadvice! org-ref-open-pdf-at-point-a ()
    "Open the pdf for bibtex key under point if it exists."
    :override #'org-ref-open-pdf-at-point
    (interactive)
    (let* ((results (org-ref-get-bibtex-key-and-file))
           (key (car results))
           (pdf-file (funcall org-ref-get-pdf-filename-function key)))
      (with-current-buffer (find-file-noselect (cdr results))
        (save-excursion
          (bibtex-search-entry (car results))
          (org-ref-open-bibtex-pdf))))))
#+end_src
***** Cdlatex
=cdlatex= is a package that is supposed to make inserting environment keys for Latex easier.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'turn-on-org-cdlatex)
#+end_src
The environment insert key =C-c }= is nice, but its also nice to edit those environments afterwards.
#+begin_src emacs-lisp
(defadvice! org-edit-latex-emv-after-insert ()
  :after #'org-cdlatex-environment-indent
  (org-edit-latex-environment))
#+end_src
***** Spellcheck
Spelling is really hard, alright?
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'turn-on-flyspell)
#+end_src
***** LSP
LSP and company in src blocks
#+begin_src emacs-lisp
(cl-defmacro lsp-org-babel-enable (lang)
  "Support LANG in org source code block."
  (setq centaur-lsp 'lsp-mode)
  (cl-check-type lang stringp)
  (let* ((edit-pre (intern (format "org-babel-edit-prep:%s" lang)))
         (intern-pre (intern (format "lsp--%s" (symbol-name edit-pre)))))
    `(progn
       (defun ,intern-pre (info)
         (let ((file-name (->> info caddr (alist-get :file))))
           (unless file-name
             (setq file-name (make-temp-file "babel-lsp-")))
           (setq buffer-file-name file-name)
           (lsp-deferred)))
       (put ',intern-pre 'function-documentation
            (format "Enable lsp-mode in the buffer of org source block (%s)."
                    (upcase ,lang)))
       (if (fboundp ',edit-pre)
           (advice-add ',edit-pre :after ',intern-pre)
         (progn
           (defun ,edit-pre (info)
             (,intern-pre info))
           (put ',edit-pre 'function-documentation
                (format "Prepare local buffer environment for org source block (%s)."
                        (upcase ,lang))))))
    ))
(defvar org-babel-lang-list
  '("go" "python" "ipython" "bash" "sh"))
(dolist (lang org-babel-lang-list)
  (eval `(lsp-org-babel-enable ,lang)))
#+end_src

***** View Exported Files
In \LaTeX, there is a keybinding ='localeader v= that shows the file you exported. It would be really nice if we had this same functionality in org.
#+begin_src emacs-lisp
(map! :map org-mode-map
      :localleader
      :desc "View exported file" "v" #'org-view-output-file)

(defun org-view-output-file (&optional org-file-path)
  "Visit buffer open on the first output file (if any) found, using `org-view-output-file-extensions'"
  (interactive)
  (let* ((org-file-path (or org-file-path (buffer-file-name) ""))
         (dir (file-name-directory org-file-path))
         (basename (file-name-base org-file-path))
         (output-file nil))
    (dolist (ext org-view-output-file-extensions)
      (unless output-file
        (when (file-exists-p
               (concat dir basename "." ext))
          (setq output-file (concat dir basename "." ext)))))
    (if output-file
        (if (member (file-name-extension output-file) org-view-external-file-extensions)
            (browse-url-xdg-open output-file)
          (pop-to-buffer (or (find-buffer-visiting output-file)
                             (find-file-noselect output-file))))
      (message "No exported file found"))))

(defvar org-view-output-file-extensions '("pdf" "md" "rst" "txt" "tex" "html")
  "Search for output files with these extensions, in order, viewing the first that matches")
(defvar org-view-external-file-extensions '("html")
  "File formats that should be opened externally.")
#+end_src
**** TODO Super Agenda
**** TODO Capture
**** TODO Roam
**** Snippet Helpers
I love the =src-blocks= of org-mode, but the headers can be a pain to:
+ Type them out
+ remember what values are valid
+ repeatedly specify languages
We can solve these problems in just a few steps:
+ Have one-letter snips, based on =(point)= being inside a src header
+ creating a nice prompt to show valid values
+ pre-filling the =src-block= language with whatever we used last
For header args, I use the following abbreviations:
+ =r= for =:results=
+ =e= for =:exports=
+ =v= for =:eval=
+ =s= for =:session=
+ =d= for =:dir=
#+begin_src emacs-lisp
(defun +yas/org-src-header-p ()
  "Determine whether `point' is within a src-block header or header-args."
  (pcase (org-element-type (org-element-context))
    ('src-block (< (point) ; before code part of the src-block
                   (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                   (forward-line 1)
                                   (point))))
    ('inline-src-block (< (point) ; before code part of the inline-src-block
                          (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                          (search-forward "]{")
                                          (point))))
    ('keyword (string-match-p "^header-args" (org-element-property :value (org-element-context))))))
#+end_src
Now we just need a function that can reference the snippets to give us options.
#+begin_src emacs-lisp
(defun +yas/org-prompt-header-arg (arg question values)
  "Prompt the user to set ARG header property to one of VALUES with QUESTION.
The default value is identified and indicated. If either default is selected,
or no selection is made: nil is returned."
  (let* ((src-block-p (not (looking-back "^#\\+property:[ \t]+header-args:.*" (line-beginning-position))))
         (default
           (or
            (cdr (assoc arg
                        (if src-block-p
                            (nth 2 (org-babel-get-src-block-info t))
                          (org-babel-merge-params
                           org-babel-default-header-args
                           (let ((lang-headers
                                  (intern (concat "org-babel-default-header-args:"
                                                  (+yas/org-src-lang)))))
                             (when (boundp lang-headers) (eval lang-headers t)))))))
            ""))
         default-value)
    (setq values (mapcar
                  (lambda (value)
                    (if (string-match-p (regexp-quote value) default)
                        (setq default-value
                              (concat value " "
                                      (propertize "(default)" 'face 'font-lock-doc-face)))
                      value))
                  values))
    (let ((selection (ivy-read question values :preselect default-value)))
      (unless (or (string-match-p "(default)$" selection)
                  (string= "" selection))
        selection))))
#+end_src
Oh, and we need to get the language for our =src-blocks=. As we already have to fetch info, we might as well do things like determine the most common language to use for things that have no =header-args= set (using =#+properties=).
#+begin_src emacs-lisp
(defun +yas/org-src-lang ()
  "Try to find the current language of the src/header at `point'.
Return nil otherwise."
  (let ((context (org-element-context)))
    (pcase (org-element-type context)
      ('src-block (org-element-property :language context))
      ('inline-src-block (org-element-property :language context))
      ('keyword (when (string-match "^header-args:\\([^ ]+\\)" (org-element-property :value context))
                  (match-string 1 (org-element-property :value context)))))))

(defun +yas/org-last-src-lang ()
  "Return the language of the last src-block, if it exists."
  (save-excursion
    (beginning-of-line)
    (when (re-search-backward "^[ \t]*#\\+begin_src" nil t)
      (org-element-property :language (org-element-context)))))

(defun +yas/org-most-common-no-property-lang ()
  "Find the lang with the most source blocks that has no global header-args, else nil."
  (let (src-langs header-langs)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*#\\+begin_src" nil t)
        (push (+yas/org-src-lang) src-langs))
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*#\\+property: +header-args" nil t)
        (push (+yas/org-src-lang) header-langs)))

    (setq src-langs
          (mapcar #'car
                  ;; sort alist by frequency (desc.)
                  (sort
                   ;; generate alist with form (value . frequency)
                   (cl-loop for (n . m) in (seq-group-by #'identity src-langs)
                            collect (cons n (length m)))
                   (lambda (a b) (> (cdr a) (cdr b))))))

    (car (cl-set-difference src-langs header-langs :test #'string=))))
#+end_src
**** Convert Old To New
Everyone used to use the =#+CAPITAL= Keywords. Later, people realized that the =#+lowercase= keywords are easier, and nicer to look at. As a result, the old capital version are only used in the manual.
#+begin_quote
Org is standardized on lower case. Uppercase is used in the manual as a poor
man's bold, and supported for historical reasons. --- [[https://orgmode.org/list/87tuuw3n15.fsf@nicolasgoaziou.fr][Nicolas Goaziou on the Org ML]]
#+end_quote
It kinda a pain to convert old documents to use the lowercase versions, so why not make a transcoding-type function to do it for us? Its not perfect, and will miss occasional edge cases, but it should work.
#+begin_src emacs-lisp
(defun org-syntax-convert-keyword-case-to-lower ()
  "Convert all #+KEYWORDS to #+keywords."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((count 0)
          (case-fold-search nil))
      (while (re-search-forward "^[ \t]*#\\+[A-Z_]+" nil t)
        (unless (s-matches-p "RESULTS" (match-string 0))
          (replace-match (downcase (match-string 0)) t)
          (setq count (1+ count))))
      (message "Replaced %d occurances" count))))
#+end_src
**** Extra Link Types
***** TODO XKCD
***** YouTube
The =[[yt:...]]= links preview nicely, but they have no idea how to correctly export. Thankfully, its possible to fix this using some typical black-magic from the web
#+begin_src emacs-lisp
(org-link-set-parameters "yt" :export #'+org-export-yt)
(defun +org-export-yt (path desc backend _com)
  (cond ((org-export-derived-backend-p backend 'html)
         (format "<iframe width='440' \
height='335' \
src='https://www.youtube.com/embed/%s' \
frameborder='0' \
allowfullscreen>%s</iframe>" path (or "" desc)))
        ((org-export-derived-backend-p backend 'latex)
         (format "\\href{https://youtu.be/%s}{%s}" path (or desc "youtube")))
        (t (format "https://youtu.be/%s" path))))
#+end_src
**** Fix Problematic Hooks
When one of the =org-mode-hook= functions errors, it halts the execution hook. This causes both problems, and a slow down, which is unacceptable. There are two such hooks that are known to cause really weird issues, so let's ignore them
#+begin_src emacs-lisp
(defadvice! shut-up-org-problematic-hooks (orig-fn &rest args)
  :around #'org-fancy-priorities-mode
  :around #'org-superstar-mode
  (ignore-errors (apply orig-fn args)))
#+end_src
*** Visuals
Here, I try to improve the styling of all my documents, by changing fonts and the like, and get colors from my current theme into the exported files, so that everyone sees my documents the same way (or as close as possible to that).
**** Font Displays
Mixed pitch is a terrific invention. =+org-pretty-mode= is just as great. Let's get them to work together.
#+begin_src emacs-lisp
(add-hook! 'org-mode-hook #'+org-pretty-mode #'mixed-pitch-mode)
#+end_src
Let's make the headings larger
#+begin_src emacs-lisp
(custom-set-faces!
  '(outline-1 :weight extra-bold :height 1.17)
  '(outline-2 :weight bold :height 1.15)
  '(outline-3 :weight bold :height 1.12)
  '(outline-4 :weight semi-bold :height 1.09)
  '(outline-5 :weight semi-bold :height 1.06)
  '(outline-6 :weight semi-bold :height 1.03)
  '(outline-8 :weight semi-bold)
  '(outline-9 :weight semi-bold))
#+end_src
Can we do the same for the title?
#+begin_src emacs-lisp
(custom-set-faces!
  '(org-document-title :height 1.2))
#+end_src
If you missed a deadline, you done messed up, and should see the error every time you open your agenda.
#+begin_src emacs-lisp
(setq org-agenda-deadline-faces
      '((1.001 . error)
        (1.0 . org-warning)
        (0.5 . org-upcoming-deadline)
        (0.0 . org-upcoming-distant-deadline)))
#+end_src
Let's make quotes and verses /look/ like quotes and verses, eh?
#+begin_src emacs-lisp
(setq org-fontify-quote-and-verse-blocks t)
#+end_src
=org-hide-emphasis-markers= is nice, but it is a pain when you have to change what's /in/ your emphasis markers. Thankfully, someone made a package that shows these markers when you're inside of it.
#+begin_src emacs-lisp
(use-package! org-appear
  :hook (org-mode . org-appear-mode)
  :config
  (setq org-appear-autoemphasis t
        org-appear-autosubmarkers t
        org-appear-autolinks nil)
  ;; for proper first-time setup, `org-appear--set-elements'
  ;; needs to be run after other hooks have acted.
  (run-at-time nil nil #'org-appear--set-elements))
#+end_src
Org files look great, especially when you do what most people do, enabling thousands of packages to make it even better. However, this comes at a cost of very slow font-locks. After lots of trial and error, people found that you can defer all of it in a batched manner, so let's do that.
#+begin_src emacs-lisp
(defun locally-defer-font-lock ()
  "Set jit-lock defer and stealth, when buffer is over a certain size."
  (when (> (buffer-size) 50000)
    (setq-local jit-lock-defer-time 0.05
                jit-lock-stealth-time 1)))
(add-hook 'org-mode-hook #'locally-defer-font-lock)
#+end_src
This has supposedly caused issues, so if I see anything weird as a result, it goes.
**** Fontifying Src Blocks
Org does lovely things with =#+begin_src= blocks, like using font-lock for language's major-mode behind the scenes and pulling out the lovely colourful results. By contrast, inline =src_= blocks are somewhat neglected.

I am not the first person to feel this way, thankfully others have [[https://stackoverflow.com/questions/20309842/how-to-syntax-highlight-for-org-mode-inline-source-code-src-lang/28059832][taken to stackexchange]] to voice their desire for inline src fontification. I was going to steal their work, but unfortunately they didn't perform /true/ source code fontification, but simply applied the =org-code= face to the content.

We can do better than that, and we shall! Using ~org-src-font-lock-fontify-block~ we can apply language-appropriate syntax highlighting. Then, continuing on to ={{{results(...)}}}= , it can have the =org-block= face applied to match, and then the value-surrounding constructs hidden by mimicking the behaviour of ~prettify-symbols-mode~.
#+begin_src emacs-lisp
(defvar org-prettify-inline-results t
  "Whether to use (ab)use prettify-symbols-mode on {{{results(...)}}}.
Either t or a cons cell of strings which are used as substitutions
for the start and end of inline results, respectively.")

(defvar org-fontify-inline-src-blocks-max-length 200
  "Maximum content length of an inline src block that will be fontified.")

(defun org-fontify-inline-src-blocks (limit)
  "Try to apply `org-fontify-inline-src-blocks-1'."
  (condition-case nil
      (org-fontify-inline-src-blocks-1 limit)
    (error (message "Org mode fontification error in %S at %d"
                    (current-buffer)
                    (line-number-at-pos)))))

(defun org-fontify-inline-src-blocks-1 (limit)
  "Fontify inline src_LANG blocks, from `point' up to LIMIT."
  (let ((case-fold-search t)
        (initial-point (point)))
    (while (re-search-forward "\\_<src_\\([^ \t\n[{]+\\)[{[]?" limit t) ; stolen from `org-element-inline-src-block-parser'
      (let ((beg (match-beginning 0))
            pt
            (lang-beg (match-beginning 1))
            (lang-end (match-end 1)))
        (remove-text-properties beg lang-end '(face nil))
        (font-lock-append-text-property lang-beg lang-end 'face 'org-meta-line)
        (font-lock-append-text-property beg lang-beg 'face 'shadow)
        (font-lock-append-text-property beg lang-end 'face 'org-block)
        (setq pt (goto-char lang-end))
        ;; `org-element--parse-paired-brackets' doesn't take a limit, so to
        ;; prevent it searching the entire rest of the buffer we temporarily
        ;; narrow the active region.
        (save-restriction
          (narrow-to-region beg (min (point-max) limit (+ lang-end org-fontify-inline-src-blocks-max-length)))
          (when (ignore-errors (org-element--parse-paired-brackets ?\[))
            (remove-text-properties pt (point) '(face nil))
            (font-lock-append-text-property pt (point) 'face 'org-block)
            (setq pt (point)))
          (when (ignore-errors (org-element--parse-paired-brackets ?\{))
            (remove-text-properties pt (point) '(face nil))
            (font-lock-append-text-property pt (1+ pt) 'face '(org-block shadow))
            (unless (= (1+ pt) (1- (point)))
              (if org-src-fontify-natively
                  (org-src-font-lock-fontify-block (buffer-substring-no-properties lang-beg lang-end) (1+ pt) (1- (point)))
                (font-lock-append-text-property (1+ pt) (1- (point)) 'face 'org-block)))
            (font-lock-append-text-property (1- (point)) (point) 'face '(org-block shadow))
            (setq pt (point))))
        (when (and org-prettify-inline-results (re-search-forward "\\= {{{results(" limit t))
          (font-lock-append-text-property pt (1+ pt) 'face 'org-block)
          (goto-char pt))))
    (when org-prettify-inline-results
      (goto-char initial-point)
      (org-fontify-inline-src-results limit))))

(defun org-fontify-inline-src-results (limit)
  (while (re-search-forward "{{{results(\\(.+?\\))}}}" limit t)
    (remove-list-of-text-properties (match-beginning 0) (point)
                                    '(composition
                                      prettify-symbols-start
                                      prettify-symbols-end))
    (font-lock-append-text-property (match-beginning 0) (match-end 0) 'face 'org-block)
    (let ((start (match-beginning 0)) (end (match-beginning 1)))
      (with-silent-modifications
        (compose-region start end (if (eq org-prettify-inline-results t) "⟨" (car org-prettify-inline-results)))
        (add-text-properties start end `(prettify-symbols-start ,start prettify-symbols-end ,end))))
    (let ((start (match-end 1)) (end (point)))
      (with-silent-modifications
        (compose-region start end (if (eq org-prettify-inline-results t) "⟩" (cdr org-prettify-inline-results)))
        (add-text-properties start end `(prettify-symbols-start ,start prettify-symbols-end ,end))))))

(defun org-fontify-inline-src-blocks-enable ()
  "Add inline src fontification to font-lock in Org.
Must be run as part of `org-font-lock-set-keywords-hook'."
  (setq org-font-lock-extra-keywords
        (append org-font-lock-extra-keywords '((org-fontify-inline-src-blocks)))))

(add-hook 'org-font-lock-set-keywords-hook #'org-fontify-inline-src-blocks-enable)
#+end_src
**** Symbols
Most of what I do in org involves making giant trees, and collapsing what I don't need to see, so I'm going to go ahead and change the collapsed items symbol to ▾. Also, while we're at it, why not add all the symbols we can ever want, and uncomment the ones we use?
#+begin_src emacs-lisp
;; (use-package org-pretty-tags
;; :config
;;  (setq org-pretty-tags-surrogate-strings
;;        `(("uni"        . ,(all-the-icons-faicon   "graduation-cap" :face 'all-the-icons-purple  :v-adjust 0.01))
;;          ("ucc"        . ,(all-the-icons-material "computer"       :face 'all-the-icons-silver  :v-adjust 0.01))
;;          ("assignment" . ,(all-the-icons-material "library_books"  :face 'all-the-icons-orange  :v-adjust 0.01))
;;          ("test"       . ,(all-the-icons-material "timer"          :face 'all-the-icons-red     :v-adjust 0.01))
;;          ("lecture"    . ,(all-the-icons-fileicon "keynote"        :face 'all-the-icons-orange  :v-adjust 0.01))
;;          ("email"      . ,(all-the-icons-faicon   "envelope"       :face 'all-the-icons-blue    :v-adjust 0.01))
;;          ("read"       . ,(all-the-icons-octicon  "book"           :face 'all-the-icons-lblue   :v-adjust 0.01))
;;          ("article"    . ,(all-the-icons-octicon  "file-text"      :face 'all-the-icons-yellow  :v-adjust 0.01))
;;          ("web"        . ,(all-the-icons-faicon   "globe"          :face 'all-the-icons-green   :v-adjust 0.01))
;;          ("info"       . ,(all-the-icons-faicon   "info-circle"    :face 'all-the-icons-blue    :v-adjust 0.01))
;;          ("issue"      . ,(all-the-icons-faicon   "bug"            :face 'all-the-icons-red     :v-adjust 0.01))
;;          ("someday"    . ,(all-the-icons-faicon   "calendar-o"     :face 'all-the-icons-cyan    :v-adjust 0.01))
;;          ("idea"       . ,(all-the-icons-octicon  "light-bulb"     :face 'all-the-icons-yellow  :v-adjust 0.01))
;;          ("emacs"      . ,(all-the-icons-fileicon "emacs"          :face 'all-the-icons-lpurple :v-adjust 0.01))))
;;  (org-pretty-tags-global-mode))

(after! org-superstar
  (setq org-superstar-headline-bullets-list '("◉" "○" "✸" "✿" "✤" "✜" "◆" "▶")
        ;; org-superstar-headline-bullets-list '("Ⅰ" "Ⅱ" "Ⅲ" "Ⅳ" "Ⅴ" "Ⅵ" "Ⅶ" "Ⅷ" "Ⅸ" "Ⅹ")
        org-superstar-prettify-item-bullets t ))

(setq org-ellipsis " ▾"
      org-hide-leading-stars t
      org-priority-highest ?A
      org-priority-lowest ?E
      org-priority-faces
      '((?A . 'all-the-icons-red)
        (?B . 'all-the-icons-orange)
        (?C . 'all-the-icons-yellow)
        (?D . 'all-the-icons-green)
        (?E . 'all-the-icons-blue)))
#+end_src
If we have unicode, why not use it everywhere?
#+begin_src emacs-lisp
(appendq! +ligatures-extra-symbols
          `(:checkbox      "☐"
            :pending       "◼"
            :checkedbox    "☑"
            :list_property "∷"
            :em_dash       "—"
            :ellipses      "…"
            :arrow_right   "→"
            :arrow_left    "←"
            :title         "𝙏"
            :subtitle      "𝙩"
            :author        "𝘼"
            :date          "𝘿"
            :property      "☸"
            :options       "⌥"
            :latex_class   "🄲"
            :latex_header  "⇥"
            :beamer_header "↠"
            :attr_latex    "🄛"
            :attr_html     "🄗"
            :begin_quote   "❝"
            :end_quote     "❞"
            :caption       "☰"
            :header        "›"
            :results       "🠶"
            :begin_export  "⏩"
            :end_export    "⏪"
            :properties    "⚙"
            :end           "∎"
            :priority_a   ,(propertize "⚑" 'face 'all-the-icons-red)
            :priority_b   ,(propertize "⬆" 'face 'all-the-icons-orange)
            :priority_c   ,(propertize "■" 'face 'all-the-icons-yellow)
            :priority_d   ,(propertize "⬇" 'face 'all-the-icons-green)
            :priority_e   ,(propertize "❓" 'face 'all-the-icons-blue)))
(set-ligatures! 'org-mode
  :merge t
  :checkbox      "[ ]"
  :pending       "[-]"
  :checkedbox    "[X]"
  :list_property "::"
  :em_dash       "---"
  :ellipsis      "..."
  :arrow_right   "->"
  :arrow_left    "<-"
  :title         "#+title:"
  :subtitle      "#+subtitle:"
  :author        "#+author:"
  :date          "#+date:"
  :property      "#+property:"
  :options       "#+options:"
  :latex_class   "#+latex_class:"
  :latex_header  "#+latex_header:"
  :beamer_header "#+beamer_header:"
  :attr_latex    "#+attr_latex:"
  :attr_html     "#+attr_html:"
  :begin_quote   "#+begin_quote"
  :end_quote     "#+end_quote"
  :caption       "#+caption:"
  :header        "#+header:"
  :begin_export  "#+begin_export"
  :end_export    "#+end_export"
  :results       "#+RESULTS:"
  :property      ":PROPERTIES:"
  :end           ":END:"
  :priority_a    "[#A]"
  :priority_b    "[#B]"
  :priority_c    "[#C]"
  :priority_d    "[#D]"
  :priority_e    "[#E]")
(plist-put +ligatures-extra-symbols :name "⁍")
#+end_src
**** \LaTeX Fragments
***** Prettier Highlighting
First off, let's make those fragments look as good as we can.
#+begin_src emacs-lisp
(setq org-highlight-latex-and-related '(native script entities))
#+end_src
Sadly, using =native= highlighting adds the =org-block= face, which looks pretty bad, especially when previews for the fragments are used.

Ideally =org-src-font-lock-fontify-block= wouldn’t add the =org-block= face, but we can avoid advising that entire function by just adding another face with =:inherit= default which will override the background colour.

Inspecting =org-do-latex-and-related= shows that ="latex"= is the language argument passed, and so we can override the background as discussed above.
#+begin_src emacs-lisp
(add-to-list 'org-src-block-faces '("latex" (:inherit default :extend t)))
#+end_src
***** More eager rendering
What's better than syntax-highlighted \LaTeX? /Rendered/ \LaTeX, obviously, which is something we can easily get with =org-fragtog=
#+begin_src emacs-lisp
(use-package! org-fragtog
  :hook (org-mode . org-fragtog-mode))
#+end_src
***** Prettier rendering
It's nice to customise the look of LaTeX fragments so they fit better in the
text --- like this \(\sqrt{\beta^2+3}-\sum_{\phi=1}^\infty \frac{x^\phi-1}{\Gamma(a)}\).
Let's start by adding a sans font. I'd also like to use some of the
functionality from =bmc-maths=, so we'll load that too.
#+begin_src emacs-lisp
(setq org-format-latex-header "\\documentclass{article}
\\usepackage[usenames]{xcolor}

\\usepackage[T1]{fontenc}

\\usepackage{booktabs}

\\pagestyle{empty}             % do not remove
% The settings below are copied from fullpage.sty
\\setlength{\\textwidth}{\\paperwidth}
\\addtolength{\\textwidth}{-3cm}
\\setlength{\\oddsidemargin}{1.5cm}
\\addtolength{\\oddsidemargin}{-2.54cm}
\\setlength{\\evensidemargin}{\\oddsidemargin}
\\setlength{\\textheight}{\\paperheight}
\\addtolength{\\textheight}{-\\headheight}
\\addtolength{\\textheight}{-\\headsep}
\\addtolength{\\textheight}{-\\footskip}
\\addtolength{\\textheight}{-3cm}
\\setlength{\\topmargin}{1.5cm}
\\addtolength{\\topmargin}{-2.54cm}
% my custom stuff
\\usepackage[nofont,plaindd]{bmc-maths}
\\usepackage{arev}
")
#+end_src
If we're already making everything run slower for aesthetics, why not make the background face transparent?
#+begin_src emacs-lisp
(setq org-format-latex-options
      (plist-put org-format-latex-options :background "Transparent"))
#+end_src
***** Rendering Benchmarking
Lots of people have done benchmarks for different \LaTeX engines, and found that =dvipng= is the fastest, and is what we'll therefore use for previews. However, this is not the highest quality, so we'll use other methods for when we export.
**** Stolen From [[https://github.com/jkitchin/scimax][SCIMAX]] (Mostly Working)
Fragment Justification
#+begin_src emacs-lisp
(defun scimax-org-latex-fragment-justify (justification)
  "Justify the latex fragment at point with JUSTIFICATION.
JUSTIFICATION is a symbol for 'left, 'center or 'right."
  (interactive
   (list (intern-soft
          (completing-read "Justification (left): " '(left center right)
                           nil t nil nil 'left))))
  (let* ((ov (ov-at))
         (beg (ov-beg ov))
         (end (ov-end ov))
         (shift (- beg (line-beginning-position)))
         (img (overlay-get ov 'display))
         (img (and (and img (consp img) (eq (car img) 'image)
                        (image-type-available-p (plist-get (cdr img) :type)))
                   img))
         space-left offset)
    (when (and img
               ;; This means the equation is at the start of the line
               (= beg (line-beginning-position))
               (or
                (string= "" (s-trim (buffer-substring end (line-end-position))))
                (eq 'latex-environment (car (org-element-context)))))
      (setq space-left (- (window-max-chars-per-line) (car (image-size img)))
            offset (floor (cond
                           ((eq justification 'center)
                            (- (/ space-left 2) shift))
                           ((eq justification 'right)
                            (- space-left shift))
                           (t
                            0))))
      (when (>= offset 0)
        (overlay-put ov 'before-string (make-string offset ?\ ))))))

(defun scimax-org-latex-fragment-justify-advice (beg end image imagetype)
  "After advice function to justify fragments."
  (scimax-org-latex-fragment-justify (or (plist-get org-format-latex-options :justify) 'left)))


(defun scimax-toggle-latex-fragment-justification ()
  "Toggle if LaTeX fragment justification options can be used."
  (interactive)
  (if (not (get 'scimax-org-latex-fragment-justify-advice 'enabled))
      (progn
        (advice-add 'org--format-latex-make-overlay :after 'scimax-org-latex-fragment-justify-advice)
        (put 'scimax-org-latex-fragment-justify-advice 'enabled t)
        (message "Latex fragment justification enabled"))
    (advice-remove 'org--format-latex-make-overlay 'scimax-org-latex-fragment-justify-advice)
    (put 'scimax-org-latex-fragment-justify-advice 'enabled nil)
    (message "Latex fragment justification disabled")))
#+end_src
While we're adding scimax code onto doom, why not take the other cool stuff they have?
#+begin_src emacs-lisp
;; Numbered equations all have (1) as the number for fragments with vanilla
;; org-mode. This code injects the correct numbers into the previews so they
;; look good.
(defun scimax-org-renumber-environment (orig-func &rest args)
  "A function to inject numbers in LaTeX fragment previews."
  (let ((results '())
        (counter -1)
        (numberp))
    (setq results (cl-loop for (begin . env) in
                           (org-element-map (org-element-parse-buffer) 'latex-environment
                             (lambda (env)
                               (cons
                                (org-element-property :begin env)
                                (org-element-property :value env))))
                           collect
                           (cond
                            ((and (string-match "\\\\begin{equation}" env)
                                  (not (string-match "\\\\tag{" env)))
                             (cl-incf counter)
                             (cons begin counter))
                            ((string-match "\\\\begin{align}" env)
                             (prog2
                                 (cl-incf counter)
                                 (cons begin counter)
                               (with-temp-buffer
                                 (insert env)
                                 (goto-char (point-min))
                                 ;; \\ is used for a new line. Each one leads to a number
                                 (cl-incf counter (count-matches "\\\\$"))
                                 ;; unless there are nonumbers.
                                 (goto-char (point-min))
                                 (cl-decf counter (count-matches "\\nonumber")))))
                            (t
                             (cons begin nil)))))

    (when (setq numberp (cdr (assoc (point) results)))
      (setf (car args)
            (concat
             (format "\\setcounter{equation}{%s}\n" numberp)
             (car args)))))

  (apply orig-func args))


(defun scimax-toggle-latex-equation-numbering ()
  "Toggle whether LaTeX fragments are numbered."
  (interactive)
  (if (not (get 'scimax-org-renumber-environment 'enabled))
      (progn
        (advice-add 'org-create-formula-image :around #'scimax-org-renumber-environment)
        (put 'scimax-org-renumber-environment 'enabled t)
        (message "Latex numbering enabled"))
    (advice-remove 'org-create-formula-image #'scimax-org-renumber-environment)
    (put 'scimax-org-renumber-environment 'enabled nil)
    (message "Latex numbering disabled.")))

(advice-add 'org-create-formula-image :around #'scimax-org-renumber-environment)
(put 'scimax-org-renumber-environment 'enabled t)
#+end_src
**** Org Plot
We can take some of the colors from our current doom theme, and inject them into the =org-plot= variables.
#+begin_src emacs-lisp
(after! org-plot
  (defun org-plot/generate-theme (_type)
    "Use the current Doom theme colours to generate a GnuPlot preamble."
    (format "
fgt = \"textcolor rgb '%s'\" # foreground text
fgat = \"textcolor rgb '%s'\" # foreground alt text
fgl = \"linecolor rgb '%s'\" # foreground line
fgal = \"linecolor rgb '%s'\" # foreground alt line

# foreground colors
set border lc rgb '%s'
# change text colors of  tics
set xtics @fgt
set ytics @fgt
# change text colors of labels
set title @fgt
set xlabel @fgt
set ylabel @fgt
# change a text color of key
set key @fgt

# line styles
set linetype 1 lw 2 lc rgb '%s' # red
set linetype 2 lw 2 lc rgb '%s' # blue
set linetype 3 lw 2 lc rgb '%s' # green
set linetype 4 lw 2 lc rgb '%s' # magenta
set linetype 5 lw 2 lc rgb '%s' # orange
set linetype 6 lw 2 lc rgb '%s' # yellow
set linetype 7 lw 2 lc rgb '%s' # teal
set linetype 8 lw 2 lc rgb '%s' # violet

# palette
set palette maxcolors 8
set palette defined ( 0 '%s',\
1 '%s',\
2 '%s',\
3 '%s',\
4 '%s',\
5 '%s',\
6 '%s',\
7 '%s' )
"
            (doom-color 'fg)
            (doom-color 'fg-alt)
            (doom-color 'fg)
            (doom-color 'fg-alt)
            (doom-color 'fg)
            ;; colours
            (doom-color 'red)
            (doom-color 'blue)
            (doom-color 'green)
            (doom-color 'magenta)
            (doom-color 'orange)
            (doom-color 'yellow)
            (doom-color 'teal)
            (doom-color 'violet)
            ;; duplicated
            (doom-color 'red)
            (doom-color 'blue)
            (doom-color 'green)
            (doom-color 'magenta)
            (doom-color 'orange)
            (doom-color 'yellow)
            (doom-color 'teal)
            (doom-color 'violet)
            ))
  (defun org-plot/gnuplot-term-properties (_type)
    (format "background rgb '%s' size 1050,650"
            (doom-color 'bg)))
  (setq org-plot/gnuplot-script-preamble #'org-plot/generate-theme)
  (setq org-plot/gnuplot-term-extra #'org-plot/gnuplot-term-properties))
#+end_src
*** Exporting
**** General Settings
#+begin_src emacs-lisp
(setq org-export-headline-levels 5) ; I like nesting
#+end_src
I’m also going to make use of an item in ox-extra so that I can add an :ignore: tag to headings for the content to be kept, but the heading itself ignored (unlike :noexport: which ignored both heading and content). This is useful when I want to use headings to provide a structure for writing that doesn’t appear in the final documents.
#+begin_src emacs-lisp
(require 'ox-extra)
(ox-extras-activate '(ignore-headlines))
#+end_src
**** Acronym Formating
Spaced small caps make great acronyms. However, there are times that they should be left unaffected, so let's use =;= to indicate this. Sadly, this must be implemented on a per-format basis, and only =HTML= and \LaTeX exports are supported
#+begin_src emacs-lisp
(defun org-export-filter-text-acronym (text backend _info)
  "Wrap suspected acronyms in acronyms-specific formatting.
Treat sequences of 2+ capital letters (optionally succeeded by \"s\") as an acronym.
Ignore if preceeded by \";\" (for manual prevention) or \"\\\" (for LaTeX commands).

TODO abstract backend implementations."
  (let ((base-backend
         (cond
          ((org-export-derived-backend-p backend 'latex) 'latex)
          ;; Markdown is derived from HTML, but we don't want to format it
          ((org-export-derived-backend-p backend 'md) nil)
          ((org-export-derived-backend-p backend 'html) 'html)))
        (case-fold-search nil))
    (when base-backend
      (replace-regexp-in-string
       "[;\\\\]?\\b[A-Z][A-Z]+s?\\(?:[^A-Za-z]\\|\\b\\)"
       (lambda (all-caps-str)
         (cond ((equal (aref all-caps-str 0) ?\\) all-caps-str)                ; don't format LaTeX commands
               ((equal (aref all-caps-str 0) ?\;) (substring all-caps-str 1))  ; just remove not-acronym indicator char ";"
               (t (let* ((final-char (if (string-match-p "[^A-Za-z]" (substring all-caps-str -1 (length all-caps-str)))
                                         (substring all-caps-str -1 (length all-caps-str))
                                       nil)) ; needed to re-insert the [^A-Za-z] at the end
                         (trailing-s (equal (aref all-caps-str (- (length all-caps-str) (if final-char 2 1))) ?s))
                         (acr (if final-char
                                  (substring all-caps-str 0 (if trailing-s -2 -1))
                                (substring all-caps-str 0 (+ (if trailing-s -1 (length all-caps-str)))))))
                    (pcase base-backend
                      ('latex (concat "\\acr{" (s-downcase acr) "}" (when trailing-s "\\acrs{}") final-char))
                      ('html (concat "<span class='acr'>" acr "</span>" (when trailing-s "<small>s</small>") final-char)))))))
       text t t))))

(add-to-list 'org-export-filter-plain-text-functions
             #'org-export-filter-text-acronym)

;; We won't use `org-export-filter-headline-functions' because it
;; passes (and formats) the entire section contents. That's no good.

(defun org-html-format-headline-acronymised (todo todo-type priority text tags info)
  "Like `org-html-format-headline-default-function', but with acronym formatting."
  (org-html-format-headline-default-function
   todo todo-type priority (org-export-filter-text-acronym text 'html info) tags info))
(setq org-html-format-headline-function #'org-html-format-headline-acronymised)

(defun org-latex-format-headline-acronymised (todo todo-type priority text tags info)
  "Like `org-latex-format-headline-default-function', but with acronym formatting."
  (org-latex-format-headline-default-function
   todo todo-type priority (org-export-filter-text-acronym text 'latex info) tags info))
(setq org-latex-format-headline-function #'org-latex-format-headline-acronymised)
#+end_src
*** \LaTeX Export
**** Compiling
By default, Org uses ~pdflatex~ \times 3 + ~bibtex~. This is terrible for performance, and simply will not do. ~latexmk~ + ~biber~ (which is used automatically by ~latexmk~) is much better, both by simplicity, and speed.
#+begin_src emacs-lisp
;; org-latex-compilers = ("pdflatex" "xelatex" "lualatex"), which are the possible values for %latex
(setq org-latex-pdf-process '("latexmk -f -pdf -%latex -shell-escape -interaction=nonstopmode -output-directory=%o %f"))
#+end_src
While ~org-latex-pdf-process~ does support a function, and we could use that
instead, this would no longer use the log buffer --- it's a bit blind, you give
it the file name and expect it to do its thing.

The default values of ~org-latex-compilers~ is given in commented form to see how
~org-latex-pdf-process~ works with them.

While the ~-%latex~ above is slightly hacky (~-pdflatex~ expects to be given a
value) it allows us to leave ~org-latex-compilers~ unmodified.
This is nice in case I open an org file that uses =#+LATEX_COMPILER= for example,
it should still work.
**** Nicer Checkboxes
We'll assume that our preamble from before is clever enough to define all of the =\checkbox...= commands mentioned below.
#+begin_src emacs-lisp
(defun +org-export-latex-fancy-item-checkboxes (text backend info)
  (when (org-export-derived-backend-p backend 'latex)
    (replace-regexp-in-string
     "\\\\item\\[{$\\\\\\(\\w+\\)$}\\]"
     (lambda (fullmatch)
       (concat "\\\\item[" (pcase (substring fullmatch 9 -3) ; content of capture group
                             ("square"   "\\\\checkboxUnchecked")
                             ("boxminus" "\\\\checkboxTransitive")
                             ("boxtimes" "\\\\checkboxChecked")
                             (_ (substring fullmatch 9 -3))) "]"))
     text)))

(add-to-list 'org-export-filter-item-functions
             '+org-export-latex-fancy-item-checkboxes)
#+end_src
**** Class Templates
#+begin_src emacs-lisp :noweb no-export
(after! ox-latex
  (add-to-list 'org-latex-classes
               '("scr-article"
                 "\\documentclass{scrartcl}"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("blank"
                 "[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("bmc-article"
                 "\\documentclass[article,code,maths]{bmc}\n[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
  (add-to-list 'org-latex-classes
               '("bmc"
                 "\\documentclass[code,maths]{bmc}\n[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                 ("\\chapter{%s}" . "\\chapter*{%s}")
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))

(setq org-latex-default-class "scr-article"
      org-latex-tables-booktabs t
      org-latex-hyperref-template "
<<latex-fancy-hyperref>>
")
#+end_src
The =hyperref= setup needs to be taken care of separately sadly.
#+name: latex-fancy-hyperref
#+begin_src LaTeX
\\colorlet{greenyblue}{blue!70!green}
\\colorlet{blueygreen}{blue!40!green}
\\providecolor{link}{named}{greenyblue}
\\providecolor{cite}{named}{blueygreen}
\\hypersetup{
  pdfauthor={%a},
  pdftitle={%t},
  pdfkeywords={%k},
  pdfsubject={%d},
  pdfcreator={%c},
  pdflang={%L},
  breaklinks=true,
  colorlinks=true,
  linkcolor=,
  urlcolor=link,
  citecolor=cite\n}
\\urlstyle{same}
#+end_src
**** A cleverer preamble
***** Use case
We often want particular snippets of LaTeX in our documents preambles.
It's a pain to have to work out / remember them every time.
For example, I almost always want to include the snippet below.

#+name: org-latex-embed-files-preamble
#+begin_src LaTeX
\\usepackage[main,include]{embedall}
\\IfFileExists{./\\jobname.org}{\\embedfile[desc=The original file]{\\jobname.org}}{}
#+end_src

We could have every package we could possibly need in every one of
~org-latex-classes~, but that's /horribly/ inefficient and I don't want to think
about maintaining that.

Instead we can provide some granularity by splitting up the features we want,
and then take the experience to a whole new level by implementing a system to
automatically detect which features are desired and generating a preamble that
provides these features.

***** Conditional Content

Let's consider content we want in particular situations.

Captions could do with a bit of tweaking such that
+ You can easily have multiple captions
+ Links to figures take you to the /top/ of the figure (not the bottom)
+ Caption labels could do with being emphasised slightly more
+ Multiline captions should run ragged-right, but only when then span more than
  one line

#+name: org-latex-caption-preamble
#+begin_src LaTeX
\\usepackage{subcaption}
\\usepackage[hypcap=true]{caption}
\\setkomafont{caption}{\\sffamily\\small}
\\setkomafont{captionlabel}{\\upshape\\bfseries}
\\captionsetup{justification=raggedright,singlelinecheck=true}
\\usepackage{capt-of} % required by Org
#+end_src

The default checkboxes look rather ugly, so let's provide some prettier alternatives.

#+name: org-latex-checkbox-preamble
#+begin_src LaTeX
\\newcommand{\\checkboxUnchecked}{$\\square$}
\\newcommand{\\checkboxTransitive}{\\rlap{\\raisebox{-0.1ex}{\\hspace{0.35ex}\\Large\\textbf -}}$\\square$}
\\newcommand{\\checkboxChecked}{\\rlap{\\raisebox{0.2ex}{\\hspace{0.35ex}\\scriptsize \\ding{52}}}$\\square$}
#+end_src

It's nice to have "message blocks", things like info/warning/error/success.
A LaTeX macro should make them trivial to create.

#+name: org-latex-box-preamble
#+begin_src LaTeX
% args = #1 Name, #2 Colour, #3 Ding, #4 Label
\\newcommand{\\defsimplebox}[4]{%
  \\definecolor{#1}{HTML}{#2}
  \\newenvironment{#1}[1][]
  {%
    \\par\\vspace{-0.7\\baselineskip}%
    \\textcolor{#1}{#3} \\textcolor{#1}{\\textbf{\\def\\temp{##1}\\ifx\\temp\\empty#4\\else##1\\fi}}%
    \\vspace{-0.8\\baselineskip}
    \\begin{addmargin}[1em]{1em}
  }{%
    \\end{addmargin}
    \\vspace{-0.5\\baselineskip}
  }%
}
#+end_src

Lastly, we will pass this content into some global variables we for ease of
access.

#+begin_src emacs-lisp :noweb no-export
(defvar org-latex-embed-files-preamble "
<<org-latex-embed-files-preamble>>
"
  "Preamble that embeds files within the pdf.")

(defvar org-latex-caption-preamble "
<<org-latex-caption-preamble>>
"
  "Preamble that improves captions.")

(defvar org-latex-checkbox-preamble "
<<org-latex-checkbox-preamble>>
"
  "Preamble that improves checkboxes.")

(defvar org-latex-box-preamble "
<<org-latex-box-preamble>>
"
  "Preamble that provides a macro for custom boxes.")
#+end_src

In the "universal preamble", we already embed the source =.org= file, but it would
be nice to embed all the tangled files. This is fairly easy to accomplish using
a cannibalised version of ~org-babel-tangle~ which just collects the file names of
each block that is tangled.

#+begin_src emacs-lisp
(defun org-babel-tangle-files ()
  "All files that may be tangled to.
Uses a stripped-down version of `org-babel-tangle'"
  (let (files)
    (save-excursion
      (mapc ;; map over all languages
       (lambda (by-lang)
         (let* ((lang (car by-lang))
                (specs (cdr by-lang))
                (ext (or (cdr (assoc lang org-babel-tangle-lang-exts)) lang)))
           (mapc
            (lambda (spec)
              (let ((get-spec (lambda (name) (cdr (assoc name (nth 4 spec))))))
                (let* ((tangle (funcall get-spec :tangle))
                       (base-name (cond
                                   ((string= "yes" tangle)
                                    (file-name-sans-extension
                                     (nth 1 spec)))
                                   ((string= "no" tangle) nil)
                                   ((> (length tangle) 0) tangle)))
                       (file-name (when base-name
                                    ;; decide if we want to add ext to base-name
                                    (if (and ext (string= "yes" tangle))
                                        (concat base-name "." ext) base-name))))
                  (push file-name files))))
            specs)))
       (org-babel-tangle-collect-blocks)))
    (delq nil (cl-delete-duplicates files :test #'string=))))
#+end_src

From here it is trivial to map each file to a form which embeds the file if it
exists.
#+begin_src emacs-lisp
(defun org-latex-embed-tangled-files ()
  "Return a string that uses embedfile to embed all tangled files."
  (mapconcat
   (lambda (tangle-file)
     (format "\\IfFileExists{%1$s}{\\embedfile[desc=A tangled file]{%1$s}}{}"
             (->> tangle-file
                  (replace-regexp-in-string "\\\\" "\\\\\\\\")
                  (replace-regexp-in-string "~" "\\\\string~"))))
   (org-babel-tangle-files)
   "\n"))
#+end_src

***** Content-feature-preamble association

Initially this idea was implemented with an alist that associated a construct
that would search the current Org file for an indication that some feature was
needed, with a \LaTeX snippet to be inserted in the preamble which would provide
that feature.
This is all well and good when there is a bijection between detected features
and the LaTeX code needed to support those features, but in many cases this
relation is not injective.

To better model the reality of the situation, I add an extra layer to this
process where each detected feature gives a list of required "feature flags".
Simply be merging the lists of feature flags we no longer have to require
injectivity to avoid \LaTeX duplication. Then the extra layer forms a bijection
between there feature flags and a specification which can be used to implement
the feature.

This model also provides a number of nice secondary benefits, such as a simple
implementation of feature dependency.

#+begin_src dot :file misc/org-latex-clever-preamble.svg :exports none
digraph {
    graph [bgcolor="transparent"];
    node  [shape="underline" penwidth="2" width="1.3" style="rounded,filled" fillcolor="#efefef" color="#c9c9c9" fontcolor="#000000" fontname="overpass"];
    edge  [color="#aaaaaa" penwidth="1.2"]
    rankdir=LR

    node[group=a,color="#2ec27e"]
    "file:*.svg"
    "file:*.jpeg"
    "file:*.png"
    "#+caption"
    "xkcd:*"
    node[group=b,color="#f5c211"]
    "svg"
    "image"
    "caption"
    node[group=c,color="#813d9c"]
    "(TeX) svg"
    "(TeX) graphicx"
    "(TeX) caption"

    "file:*.svg" -> "svg" -> "(TeX) svg"
    "file:*.jpeg" -> "image" -> "(TeX) graphicx"
    "file:*.png" -> "image"
    "(TeX) svg":s -> "(TeX) graphicx":n [constraint=false]
    "#+caption" -> "caption" -> "(TeX) caption"
    "xkcd:*" -> "image"
    "xkcd:*" -> "caption"
}
#+end_src

#+caption: Association between Org features, feature flags, and LaTeX snippets required.
#+attr_html: :class invertible :alt DAG showing how Org features flow through to LaTeX :style max-width:min(24em,100%)
#+attr_latex: :width 0.6\linewidth
[[file:misc/org-latex-clever-preamble.svg]]

First we will implement the feature detection component of this model. I'd like
this to be able to use as much state information as possible, so the feature
tests should be very versatile.

#+begin_src emacs-lisp
(defvar org-latex-embed-files t
  "Embed the source .org, .tex, and any tangled files.")
(defvar org-latex-use-microtype t
  "Use the microtype pakage.")
(defvar org-latex-italic-quotes t
  "Make \"quote\" environments italic.")
(defvar org-latex-par-sep t
  "Vertically seperate paragraphs, and remove indentation.")

(defvar org-latex-conditional-features
  '(("\\[\\[\\(?:file\\|https?\\):\\(?:[^]]\\|\\\\\\]\\)+?\\.\\(?:eps\\|pdf\\|png\\|jpeg\\|jpg\\|jbig2\\)\\]\\]" . image)
    ("\\[\\[\\(?:file\\|https?\\):\\(?:[^]]+?\\|\\\\\\]\\)\\.svg\\]\\]" . svg)
    ("\\\\(\\|\\\\\\[\\|\\\\begin{\\(?:math\\|displaymath\\|equation\\|align\\|flalign\\|multiline\\|gather\\)[a-z]*\\*?}" . maths)
    ("^[ \t]*|" . table)
    ("cref:\\|\\cref{" . cleveref)
    ("[;\\\\]?\\b[A-Z][A-Z]+s?[^A-Za-z]" . acronym)
    ("\\+[^ ].*[^ ]\\+\\|_[^ ].*[^ ]_\\|\\\\uu?line\\|\\\\uwave\\|\\\\sout\\|\\\\xout\\|\\\\dashuline\\|\\dotuline\\|\\markoverwith" . underline)
    (":float wrap" . float-wrap)
    (":float sideways" . rotate)
    ("^[ \t]*#\\+caption:\\|\\\\caption" . caption)
    ("\\[\\[xkcd:" . (image caption))
    (org-latex-use-microtype . microtype)
    ((and org-latex-italic-quotes "^[ \t]*#\\+begin_quote\\|\\\\begin{quote}") . italic-quotes)
    (org-latex-par-sep . par-sep)
    ((org-latex-embed-tangled-files) . embed-files)
    ((and org-latex-embed-files "^[ \t]*#\\+begin_src\\|^[ \t]*#\\+BEGIN_SRC") . embed-tangled)
    ("^[ \t]*\\(?:[-+*]\\|[0-9]+[.)]\\|[A-Za-z]+[.)]\\) \\[[ -X]\\]" . checkbox)
    ("^[ \t]*#\\+begin_warning\\|\\\\begin{warning}" . box-warning)
    ("^[ \t]*#\\+begin_info\\|\\\\begin{info}"       . box-info)
    ("^[ \t]*#\\+begin_success\\|\\\\begin{success}" . box-success)
    ("^[ \t]*#\\+begin_error\\|\\\\begin{error}"     . box-error))
  "Org feature tests and associated LaTeX feature flags.

Alist where the car is a test for the presense of the feature,
and the cdr is either a single feature symbol or list of feature symbols.

When a string, it is used as a regex search in the buffer.
The feature is registered as present when there is a match.

The car can also be a
- symbol, the value of which is fetched
- function, which is called with info as an argument
- list, which is `eval'uated

If the symbol, function, or list produces a string: that is used as a regex
search in the buffer. Otherwise any non-nil return value will indicate the
existance of the feature.")
#+end_src

Then we provide a way to generate the preamble that provides those features.
In addition to the features named in ~org-latex-conditional-features~ we'll also
create /meta-features/, which can be required by other features (with =:requires=),
or be active by default (=:eager t=). For further control I some features may only
be used when certain other features are active (with =:when=), and masked by other
features (with =:prevents=). I will use the convention of starting meta-features
with =.=, and =:eager= features with =!= to make their nature more readily apparent.

Another consideration in LaTeX is load order, which matters in some cases.
Beyond that, it's nice to have some sort of sensible ordering. For this I'll
introduce an =:order= keyword. Using this I'll arrange snippets as follows.

+ =-2= Embed files setup
+ =-1= Extra file embedding
+ =0= Typography
  - =0= Fonts themselves
  - =0.1= Typographic tweaks (=microtype=)
  - =0.2= Maths setup
  - =0.3= Maths font
  - =0.4= Extra text shaping (~\acr~)
  - =0.5-0.9= Miscellaneous text modifications, trying to put shorter snippets first
+ =1= (/default/)
+ =2= Tables and figures
+ =3= Miscellaneous short content
+ =4= Fancy boxes

#+begin_src emacs-lisp
(defvar org-latex-feature-implementations
  '((image         :snippet "\\usepackage{graphicx}" :order 2)
    (svg           :snippet "\\usepackage{svg}" :order 2)
    (maths         :snippet "\\usepackage[nofont]{bmc-maths}" :order 0.2)
    (table         :snippet "\\usepackage{longtable}\n\\usepackage{booktabs}" :order 2)
    (cleveref      :snippet "\\usepackage{cleveref}" :order 1) ; after bmc-maths
    (underline     :snippet "\\usepackage[normalem]{ulem}" :order 0.5)
    (float-wrap    :snippet "\\usepackage{wrapfig}" :order 2)
    (rotate        :snippet "\\usepackage{rotating}" :order 2)
    (caption       :snippet org-latex-caption-preamble :order 2.1)
    (microtype     :snippet "\\usepackage[activate={true,nocompatibility},final,tracking=true,kerning=true,spacing=true,factor=2000]{microtype}\n" :order 0.1)
    (embed-files   :snippet org-latex-embed-files-preamble :order -2)
    (embed-tangled :requires embed-files :snippet (concat (org-latex-embed-tangled-files) "\n") :order -1)
    (acronym       :snippet "\\newcommand{\\acr}[1]{\\protect\\textls*[110]{\\scshape #1}}\n\\newcommand{\\acrs}{\\protect\\scalebox{.91}[.84]{\\hspace{0.15ex}s}}" :order 0.4)
    (italic-quotes :snippet "\\renewcommand{\\quote}{\\list{}{\\rightmargin\\leftmargin}\\item\\relax\\em}\n" :order 0.5)
    (par-sep       :snippet "\\setlength{\\parskip}{\\baselineskip}\n\\setlength{\\parindent}{0pt}\n" :order 0.5)
    (.pifont       :snippet "\\usepackage{pifont}")
    (checkbox      :requires .pifont :order 3
                   :snippet (concat (unless (memq 'maths features)
                                      "\\usepackage{amssymb} % provides \\square")
                                    org-latex-checkbox-preamble))
    (.fancy-box    :requires .pifont    :snippet org-latex-box-preamble :order 3.9)
    (box-warning   :requires .fancy-box :snippet "\\defsimplebox{warning}{e66100}{\\ding{68}}{Warning}" :order 4)
    (box-info      :requires .fancy-box :snippet "\\defsimplebox{info}{3584e4}{\\ding{68}}{Information}" :order 4)
    (box-success   :requires .fancy-box :snippet "\\defsimplebox{success}{26a269}{\\ding{68}}{\\vspace{-\\baselineskip}}" :order 4)
    (box-error     :requires .fancy-box :snippet "\\defsimplebox{error}{c01c28}{\\ding{68}}{Important}" :order 4))
  "LaTeX features and details required to implement them.

List where the car is the feature symbol, and the rest forms a plist with the
following keys:
- :snippet, which may be either
  - a string which should be included in the preamble
  - a symbol, the value of which is included in the preamble
  - a function, which is evaluated with the list of feature flags as its
    single argument. The result of which is included in the preamble
  - a list, which is passed to `eval', with a list of feature flags available
    as \"features\"

- :requires, a feature or list of features that must be available
- :when, a feature or list of features that when all available should cause this
    to be automatically enabled.
- :prevents, a feature or list of features that should be masked
- :order, for when ordering is important. Lower values appear first.
    The default is 0.

Features that start with ! will be eagerly loaded, i.e. without being detected.")
#+end_src

***** Feature determination

Now that we have ~org-latex-conditional-features~ defined, we need to use it to
extract a list of features found in an Org buffer.

#+begin_src emacs-lisp
(defun org-latex-detect-features (&optional buffer info)
  "List features from `org-latex-conditional-features' detected in BUFFER."
  (let ((case-fold-search nil))
    (with-current-buffer (or buffer (current-buffer))
      (delete-dups
       (apply #'append
              (mapcar (lambda (construct-feature)
                        (when (let ((out (pcase (car construct-feature)
                                           ((pred stringp) (car construct-feature))
                                           ((pred functionp) (funcall (car construct-feature) info))
                                           ((pred listp) (eval (car construct-feature)))
                                           ((pred symbolp) (symbol-value (car construct-feature)))
                                           (_ (user-error "org-latex-conditional-features key %s unable to be used" (car construct-feature))))))
                                (if (stringp out)
                                    (save-excursion
                                      (goto-char (point-min))
                                      (re-search-forward out nil t))
                                  out))
                          (if (listp (cdr construct-feature)) (cdr construct-feature) (list (cdr construct-feature)))))
                      org-latex-conditional-features))))))
#+end_src

***** Preamble generation

Once a list of required features has been determined, we want to use
~org-latex-feature-implementations~ to generate the LaTeX which should be inserted
into the preamble to provide those features.

First we want to process our fancy keywords in ~org-latex-feature-implementations~
to produce an /expanded/ list of features. We'll do that by performing the
following steps.
+ The dependencies for each listed feature are added to feature list
  (src_elisp{:requires}).
+ The src_elisp{:when} conditions of each feature, and available features with
  src_elisp{:eager t}, are evaluated, and added/removed accordingly
+ Any features present in a src_elisp{:prevents} value are removed
+ The feature list is scrubbed of duplicates
+ The feature list is sorted by src_elisp{:order} (ascending)

#+begin_src emacs-lisp
(defun org-latex-expand-features (features)
  "For each feature in FEATURES process :requires, :when, and :prevents keywords and sort according to :order."
  (dolist (feature features)
    (unless (assoc feature org-latex-feature-implementations)
      (error "Feature %s not provided in org-latex-feature-implementations" feature)))
  (setq current features)
  (while current
    (when-let ((requirements (plist-get (cdr (assq (car current) org-latex-feature-implementations)) :requires)))
      (setcdr current (if (listp requirements)
                          (append requirements (cdr current))
                        (cons requirements (cdr current)))))
    (setq current (cdr current)))
  (dolist (potential-feature
           (append features (delq nil (mapcar (lambda (feat)
                                                (when (plist-get (cdr feat) :eager)
                                                  (car feat)))
                                              org-latex-feature-implementations))))
    (when-let ((prerequisites (plist-get (cdr (assoc potential-feature org-latex-feature-implementations)) :when)))
      (setf features (if (if (listp prerequisites)
                             (cl-every (lambda (preq) (memq preq features)) prerequisites)
                           (memq prerequisites features))
                         (append (list potential-feature) features)
                       (delq potential-feature features)))))
  (dolist (feature features)
    (when-let ((prevents (plist-get (cdr (assoc feature org-latex-feature-implementations)) :prevents)))
      (setf features (cl-set-difference features (if (listp prevents) prevents (list prevents))))))
  (sort (delete-dups features)
        (lambda (feat1 feat2)
          (if (< (or (plist-get (cdr (assoc feat1 org-latex-feature-implementations)) :order) 1)
                 (or (plist-get (cdr (assoc feat2 org-latex-feature-implementations)) :order) 1))
              t nil))))
#+end_src

Now that we have a nice list of the final features to use, we can just pull out
their snippets and join the result together.

#+begin_src emacs-lisp
(defun org-latex-generate-features-preamble (features)
  "Generate the LaTeX preamble content required to provide FEATURES.
This is done according to `org-latex-feature-implementations'"
  (let ((expanded-features (org-latex-expand-features features)))
    (concat
     (format "\n%% features: %s\n" expanded-features)
     (mapconcat (lambda (feature)
                  (when-let ((snippet (plist-get (cdr (assoc feature org-latex-feature-implementations)) :snippet)))
                    (concat
                     (pcase snippet
                       ((pred stringp) snippet)
                       ((pred functionp) (funcall snippet features))
                       ((pred listp) (eval `(let ((features ',features)) (,@snippet))))
                       ((pred symbolp) (symbol-value snippet))
                       (_ (user-error "org-latex-feature-implementations :snippet value %s unable to be used" snippet)))
                     "\n")))
                expanded-features
                "")
     "% end features\n")))
#+end_src

Then Org needs to be advised to actually use this generated preamble content.

#+begin_src emacs-lisp
(defvar info--tmp nil)

(defadvice! org-latex-save-info (info &optional t_ s_)
  :before #'org-latex-make-preamble
  (setq info--tmp info))

(defadvice! org-splice-latex-header-and-generated-preamble-a (orig-fn tpl def-pkg pkg snippets-p &optional extra)
  "Dynamically insert preamble content based on `org-latex-conditional-preambles'."
  :around #'org-splice-latex-header
  (let ((header (funcall orig-fn tpl def-pkg pkg snippets-p extra)))
    (if snippets-p header
      (concat header
              (org-latex-generate-features-preamble (org-latex-detect-features nil info--tmp))
              "\n"))))
#+end_src

My use of ~info--tmp~ is somewhat hacky. When I try to upstream this, this should
become much cleaner as I can pass info through by directly modifying
~org-latex-make-preamble~.

***** Reduce default packages

Thanks to our additions, we can remove a few packages from
~org-latex-default-packages-alist~.

There are also some obsolete entries in the default value, specifically
+ =grffile='s capabilities are built into the current version of =graphicx=
+ =textcomp='s functionality has been included in LaTeX's core for a while now

#+begin_src emacs-lisp
(setq org-latex-default-packages-alist
      '(("AUTO" "inputenc" t ("pdflatex"))
        ("T1" "fontenc" t ("pdflatex"))
        ("" "xcolor" nil) ; Generally useful
        ("" "hyperref" nil)))
#+end_src
**** Font collections

Using the lovely conditional preamble, I'll define a number of font collections
that can be used for LaTeX exports. Who knows, maybe I'll use it with other
export formats too at some point.

To start with I'll create a default state variable and register =fontset= as part
of =#+options=.

#+begin_src emacs-lisp
(defvar org-latex-default-fontset 'cantarell
  "Fontset from `org-latex-fontsets' to use by default.
As cm (computer modern) is TeX's default, that causes nothing
to be added to the document.

If \"nil\" no custom fonts will ever be used.")

(eval '(cl-pushnew '(:latex-font-set nil "fontset" org-latex-default-fontset)
                   (org-export-backend-options (org-export-get-backend 'latex))))
#+end_src

Then a function is needed to generate a LaTeX snippet which applies the fontset. It
would be nice if this could be done for individual styles and use different
styles as the main document font. If the individual typefaces for a fontset are
defined individually as
src_elisp{:serif}, src_elisp{:sans}, src_elisp{:mono}, and src_elisp{:maths}.
I can use those to generate LaTeX for subsets of the full fontset. Then, if I
don't let any fontset names have =-= in them, I can use =-sans= and =-mono= as
suffixes that specify the document font to use.

#+begin_src emacs-lisp
(defun org-latex-fontset-entry ()
  "Get the fontset spec of the current file.
Has format \"name\" or \"name-style\" where 'name' is one of
the cars in `org-latex-fontsets'."
  (let ((fontset-spec
         (symbol-name
          (or (car (delq nil
                         (mapcar
                          (lambda (opt-line)
                            (plist-get (org-export--parse-option-keyword opt-line 'latex)
                                       :latex-font-set))
                          (cdar (org-collect-keywords '("OPTIONS"))))))
              org-latex-default-fontset))))
    (cons (intern (car (split-string fontset-spec "-")))
          (when (cadr (split-string fontset-spec "-"))
            (intern (concat ":" (cadr (split-string fontset-spec "-"))))))))

(defun org-latex-fontset (&rest desired-styles)
  "Generate a LaTeX preamble snippet which applies the current fontset for DESIRED-STYLES."
  (let* ((fontset-spec (org-latex-fontset-entry))
         (fontset (alist-get (car fontset-spec) org-latex-fontsets)))
    (if fontset
        (concat
         (mapconcat
          (lambda (style)
            (when (plist-get fontset style)
              (concat (plist-get fontset style) "\n")))
          desired-styles
          "")
         (when (memq (cdr fontset-spec) desired-styles)
           (pcase (cdr fontset-spec)
             (:serif "\\renewcommand{\\familydefault}{\\rmdefault}\n")
             (:sans "\\renewcommand{\\familydefault}{\\sfdefault}\n")
             (:mono "\\renewcommand{\\familydefault}{\\ttdefault}\n"))))
      (error "Font-set %s is not provided in org-latex-fontsets" (car fontset-spec)))))
#+end_src

Now that all the functionality has been implemented, we should hook it into our
preamble generation.

#+begin_src emacs-lisp
(add-to-list 'org-latex-conditional-features '(org-latex-default-fontset . custom-font) t)
(add-to-list 'org-latex-feature-implementations '(custom-font :snippet (org-latex-fontset :serif :sans :mono) :order 0) t)
(add-to-list 'org-latex-feature-implementations '(.custom-maths-font :eager t :when (custom-font maths) :snippet (org-latex-fontset :maths) :order 0.3) t)
#+end_src

Finally, we just need to add some fonts.

#+begin_src emacs-lisp
(defvar org-latex-fontsets
  '((cm nil) ; computer modern
    (cantarell
     :serif "\\usepackage[osf]{Alegreya}"
     :sans "\\usepackage{AlegreyaSans}"
     :mono "\\usepackage[scale=0.88]{sourcecodepro}"
     :maths "\\usepackage[varbb]{newpxmath}")
    (biolinum
     :serif "\\usepackage[osf]{libertineRoman}"
     :sans "\\usepackage[sfdefault,osf]{biolinum}"
     :mono "\\usepackage[scale=0.88]{sourcecodepro}"
     :maths "\\usepackage[libertine,varvw]{newtxmath}")
    (fira
     :sans "\\usepackage[sfdefault,scale=0.85]{FiraSans}"
     :mono "\\usepackage[scale=0.80]{FiraMono}"
     :maths "\\usepackage{newtxsf} % change to firamath in future?")
    (kp
     :serif "\\usepackage{kpfonts}")
    (newpx
     :serif "\\usepackage{newpxtext}"
     :sans "\\usepackage{gillius}"
     :mono "\\usepackage[scale=0.9]{sourcecodepro}"
     :maths "\\usepackage[varbb]{newpxmath}")
    (noto
     :serif "\\usepackage[osf]{noto-serif}"
     :sans "\\usepackage[osf]{noto-sans}"
     :mono "\\usepackage[scale=0.96]{noto-mono}"
     ;; Wait till TeXlive 2021 is released, use notomath
     :maths "\\usepackage{newtxmath}")
    (plex
     :serif "\\usepackage{plex-serif}"
     :sans "\\usepackage{plex-sans}"
     :mono "\\usepackage[scale=0.95]{plex-mono}"
     :maths "\\usepackage{newtxmath}") ; may be plex-based in future
    (source
     :serif "\\usepackage[osf]{sourceserifpro}"
     :sans "\\usepackage[osf]{sourcesanspro}"
     :mono "\\usepackage[scale=0.95]{sourcecodepro}"
     :maths "\\usepackage{newtxmath}") ; may be sourceserifpro-based in future
    (times
     :serif "\\usepackage{newtxtext}"
     :maths "\\usepackage{newtxmath}"))
  "Alist of fontset specifications.
Each car is the name of the fontset (which cannot include \"-\").

Each cdr is a plist with (optional) keys :serif, :sans, :mono, and :maths.
A key's value is a LaTeX snippet which loads such a font.")
#+end_src

When we're using Alegreya we can apply a lovely little tweak to =tabular= which
(locally) changes the figures used to lining fixed-width.

#+begin_src emacs-lisp
(add-to-list 'org-latex-conditional-features '((string= (car (org-latex-fontset-entry)) "cantarell") . cantarell-typeface))
(add-to-list 'org-latex-feature-implementations '(cantarell-typeface) t)
(add-to-list 'org-latex-feature-implementations'(.cantarell-tabular-figures :eager t :when (cantarell-typeface table) :order 0.5 :snippet "
\\makeatletter
% tabular lining figures in tables
\\renewcommand{\\tabular}{\\AlegreyaTLF\\let\\@halignto\\@empty\\@tabular}
\\makeatother\n") t)
#+end_src

Due to the Alegreya's metrics, the =\LaTeX= symbol doesn't quite look right. We
can correct for this by redefining it with subtlety shifted kerning.

#+begin_src emacs-lisp
(add-to-list 'org-latex-conditional-features '("LaTeX" . latex-symbol))
(add-to-list 'org-latex-feature-implementations '(latex-symbol :when cantarell-typeface :order 0.5 :snippet "
\\makeatletter
% Kerning around the A needs adjusting
\\DeclareRobustCommand{\\LaTeX}{L\\kern-.24em%
        {\\sbox\\z@ T%
         \\vbox to\\ht\\z@{\\hbox{\\check@mathfonts
                              \\fontsize\\sf@size\\z@
                              \\math@fontsfalse\\selectfont
                              A}%
                        \\vss}%
        }%
        \\kern-.10em%
        \\TeX}
\\makeatother\n") t)
#+end_src
*** UI
This change the fonts and formatting of org mode to make it much better looking.
#+begin_src emacs-lisp
(defun doom/org-font-setup ()
  ;; Replace list hyphen with dot
  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

  ;; Set faces for heading levels
  (dolist (face '((org-level-1 . 1.2)
                  (org-level-2 . 1.15)
                  (org-level-3 . 1.10)
                  (org-level-4 . 1.05)
                  (org-level-5 . 1.1)
                  (org-level-6 . 1.1)
                  (org-level-7 . 1.1)
                  (org-level-8 . 1.1)))
    (set-face-attribute (car face) nil :font "Cantarell" :weight 'regular :height (cdr face)))

  ;; Ensure that anything that should be fixed-pitch in Org files appears that way
  (set-face-attribute 'org-block nil    :foreground nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-table nil    :inherit 'fixed-pitch)
  (set-face-attribute 'org-formula nil  :inherit 'fixed-pitch)
  (set-face-attribute 'org-code nil     :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-table nil    :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-checkbox nil  :inherit 'fixed-pitch)
  (set-face-attribute 'line-number nil :inherit 'fixed-pitch)
  (set-face-attribute 'line-number-current-line nil :inherit 'fixed-pitch)
  (setq visual-fill-column-width 170
        visual-fill-column-center-text t)
  (visual-fill-column-mode 1))

(use-package! org-pretty-table
  :commands (org-pretty-table-mode global-org-pretty-table-mode))
#+end_src
*** GENERAL SETUP
I have also enabled org-journal by adding (+journal) to the org section of my Doom Emacs init.el. I have this at the bottom of org mode so I can use my utility functions

#+begin_src emacs-lisp
(setq org-directory "~/org/"
      org-todo-keywords      ; This overwrites the default Doom org-todo-keywords
      '((sequence
         "TODO(t)"           ; A task that is ready to tackle
         "SCHOOL(s)"         ; School related assignments
         "PROJ(p)"           ; A project that contains other tasks
         "WAIT(w)"           ; Something is holding up this task
         "|"                 ; The pipe necessary to separate "active" states and "inactive" states
         "DONE(d)"           ; Task has completed
         "CANCELLED(c)"))) ; Task has cancelled
#+end_src
** LaTeX
*** Compilation
#+begin_src emacs-lisp
(setq TeX-save-query nil
      TeX-show-compilation t
      TeX-command-extra-options "-shell-escape")
(after! latex
  (add-to-list 'TeX-command-list '("XeLaTeX" "%`xelatex%(mode)%' %t" TeX-run-TeX nil t)))
#+end_src
For viewing the =PDF=, I rather like the pdf-tools viewer. AucTeX, being as difficult as AucTeX is, decided to instead enforce that i use a system =PDF= viewer, so...
#+begin_src emacs-lisp
(setq +latex-viewers '(pdf-tools evince zathura okular skim sumatrapdf))
#+end_src
*** Template
When we make a new file, be nice and give us a preamble. To do that, bind the content to a function, and make yet more functions.
#+begin_src emacs-lisp
(setq doom/gyas-latex-template-preamble "
<<latex-nice-preamble>>
")

(defun doom/gyas-latex-get-class-choice ()
  "Prompt user for LaTeX class choice"
  (setq doom/gyas-latex-class-choice (ivy-read "Select document class: " '("article" "scrartcl" "bmc") :def "bmc")))

(defun doom/gyas-latex-preamble-if ()
  "Based on class choice prompt for insertion of default preamble"
  (if (equal doom/gyas-latex-class-choice "bmc") 'nil
    (eq (read-char-choice "Include default preamble? [Type y/n]" '(?y ?n)) ?y)))
#+end_src
* SHELLS
Settings for the various shells and terminal emulators within Emacs.
+ 'shell-file-name' -- sets the shell to be used in M-x shell, M-x term, M-x ansi-term and M-x vterm.
+ 'eshell-aliases-file' -- sets an aliases file for the eshell.

#+begin_src emacs-lisp
(setq shell-file-name "/bin/zsh"
      eshell-aliases-file "~/.config/doom/aliases"
      eshell-history-size 5000
      eshell-buffer-maximum-lines 5000
      eshell-hist-ignoredups t
      eshell-scroll-to-bottom-on-input t
      eshell-destroy-buffer-when-process-dies t
      eshell-visual-commands'("bash" "htop" "ssh" "zsh")
      vterm-max-scrollback 5000)
(map! :leader
      :desc "Counsel eshell history"
      "e h" #'counsel-esh-history)
#+end_src

* SPLITS
I set splits to default to opening on the right using 'prefer-horizontal-split'. I set a keybinding for 'clone-indirect-buffer-other-window' for when I want to have the same document in two splits. The text of the indirect buffer is always identical to the text of its base buffer; changes made by editing either one are visible immediately in the other. But in all other respects, the indirect buffer and its base buffer are completely separate. For example, I can fold one split but other will be unfolded.

#+begin_src emacs-lisp
(defun prefer-horizontal-split ()
  (set-variable 'split-height-threshold nil t)
  (set-variable 'split-width-threshold 40 t)) ; make this as low as needed
(add-hook 'markdown-mode-hook 'prefer-horizontal-split)
(map! :leader
      :desc "Clone indirect buffer other window"
      "b c" #'clone-indirect-buffer-other-window)
#+end_src

* SPELLCHECK
Emacs needs to know the default dictionary to use with spell backends like aspell.
#+begin_src emacs-lisp
(setq ispell-dictionary "en")
#+end_src

* PASSWORDS
This sets up the auth-source library and adds functions to access passwords outside of emacs
#+begin_src emacs-lisp
(defun lookup-password (&rest keys)
  (let ((result (apply #'auth-source-search keys)))
    (if result
        (funcall (plist-get (car result) :secret))
      nil)))
#+end_src

* ELFEED
Doom adds the elfeed-org plugin with elfeed, meaning that feeds can be configured with org.
** root :elfeed:
*** [[https://archlinux.org/feeds/news/][ArchLinux News]] :arch:

* VERY LARGE FILES MODE
This package makes it possible to open *massive* files by loading them from disc incrementally in chunks.
#+begin_src emacs-lisp
(use-package! vlf-setup
  :defer-incrementally vlf-tune vlf-base vlf-write vlf-search vlf-occur vlf-follow vlf-ediff vlf)
#+end_src

* EMACS EVERYWHERE
Now who wouldn't want this?
#+begin_src emacs-lisp
(when (daemonp)
  (require 'spell-fu)
  (setq emacs-everywhere-major-mode-function #'org-mode
        emacs-everywhere-frame-name-format "Edit ∷ %s — %s")
  (require 'emacs-everywhere))
#+end_src

* WHICH-KEY
Does =evil-= need to appear on every binding? No.
#+begin_src emacs-lisp
(setq which-key-allow-multiple-replacements t)
(after! which-key
  (pushnew!
   which-key-replacement-alist
   '(("" . "\\`+?evil[-:]?\\(?:a-\\)?\\(.*\\)") . (nil . "◂\\1"))
   '(("\\`g s" . "\\`evilem--?motion-\\(.*\\)") . (nil . "◃\\1"))
   ))
#+end_src

* ZEN
Doom zooms in too much
#+begin_src emacs-lisp
(setq +zen-text-scale 0.8)
#+end_src

When zen is on in org, keep org nice, thank you!
#+begin_src emacs-lisp
(defvar +zen-serif-p nil
  "Whether to use a serifed font with `mixed-pitch-mode'.")
(after! writeroom-mode
  (defvar-local +zen--original-org-indent-mode-p nil)
  (defvar-local +zen--original-mixed-pitch-mode-p nil)
  (defvar-local +zen--original-solaire-mode-p nil)
  (defvar-local +zen--original-org-pretty-table-mode-p t)
  (defun +zen-enable-mixed-pitch-mode-h ()
    "Enable `mixed-pitch-mode' when in `+zen-mixed-pitch-modes'."
    (when (apply #'derived-mode-p +zen-mixed-pitch-modes)
      (if writeroom-mode
          (progn
            (setq +zen--original-solaire-mode-p solaire-mode)
            (solaire-mode -1)
            (setq +zen--original-mixed-pitch-mode-p mixed-pitch-mode)
            (funcall (if +zen-serif-p #'mixed-pitch-serif-mode #'mixed-pitch-mode) 1))
        (funcall #'mixed-pitch-mode (if +zen--original-mixed-pitch-mode-p 1 -1))
        (when +zen--original-solaire-mode-p (solaire-mode 1)))))
  (pushnew! writeroom--local-variables
            'display-line-numbers
            'visual-fill-column-width
            'org-adapt-indentation
            'org-superstar-headline-bullets-list
            'org-superstar-remove-leading-stars)
  (add-hook 'writeroom-mode-enable-hook
            (defun +zen-prose-org-h ()
              "Reformat the current Org buffer appearance for prose."
              (when (eq major-mode 'org-mode)
                (setq display-line-numbers nil
                      visual-fill-column-width 60
                      org-adapt-indentation nil)
                (when (featurep 'org-superstar)
                  (setq-local org-superstar-headline-bullets-list '("🙘" "🙙" "🙚" "🙛")
                              ;; org-superstar-headline-bullets-list '("🙐" "🙑" "🙒" "🙓" "🙔" "🙕" "🙖" "🙗")
                              org-superstar-remove-leading-stars t)
                  (org-superstar-restart))
                (setq
                 +zen--original-org-indent-mode-p org-indent-mode
                 +zen--original-org-pretty-table-mode-p (bound-and-true-p org-pretty-table-mode))
                (org-indent-mode -1)
                (org-pretty-table-mode 1))))
  (add-hook 'writeroom-mode-disable-hook
            (defun +zen-nonprose-org-h ()
              "Reverse the effect of `+zen-prose-org'."
              (when (eq major-mode 'org-mode)
                (when (featurep 'org-superstar)
                  (org-superstar-restart))
                (when +zen--original-org-indent-mode-p (org-indent-mode 1))
                ;; (unless +zen--original-org-pretty-table-mode-p (org-pretty-table-mode -1))
                ))))
#+end_src

